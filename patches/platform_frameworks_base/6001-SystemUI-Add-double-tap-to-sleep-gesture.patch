From 2da2d655c2ea85a758feb3130fac1386d504ca03 Mon Sep 17 00:00:00 2001
From: Dalingrin <dalingrin@gmail.com>
Date: Fri, 6 May 2016 03:43:03 +0200
Subject: [PATCH 1/1] SystemUI: Add double tap to sleep gesture

Change-Id: I708338e6ac069856c3f4da1ae2fd8029a7899e1c
Signed-off-by: spezi77 <spezi7713@gmx.net>

SystemUI: double tap to sleep improvements

* Make it more reliable
* Add it to keyguard
* Add a content observer to not always query Settings.System on every
touch event

Change-Id: I1642ab4f14deb59db8ff7de47f6110b678b91d0f
Signed-off-by: spezi77 <spezi7713@gmx.net>

SystemUI: Double tap to sleep on the lock screen (1/2)

Change-Id: I7c163b1368eb1aea409b4dce6b92841cb13d4ec8
Signed-off-by: spezi77 <spezi7713@gmx.net>

SystemUI: prevent that dt2s triggers panel expand

http://jira.omnirom.org/browse/OMNI-1466

Change-Id: If304577d666ebf8423cca1298dfbe044843657cc
Signed-off-by: spezi77 <spezi7713@gmx.net>

SystemUI: refactor quick settings expand fix

not only for dt2s - make sure qs cant stay expanded once
keyguard is started

Change-Id: Ie8778544a529a93ccb0afb25f3a30a3ba50017dc
Signed-off-by: spezi77 <spezi7713@gmx.net>
Signed-off-by: AndroPlus <mail@andro.plus>
---
 core/java/android/provider/Settings.java      |   12 +
 .../phone/NotificationPanelView.java          | 1012 ++++++++---------
 .../statusbar/phone/StatusBarWindowView.java  |  237 ++--
 3 files changed, 661 insertions(+), 600 deletions(-)

diff --git a/core/java/android/provider/Settings.java b/core/java/android/provider/Settings.java
index 4d8608081ef..ab15918909c 100644
--- a/core/java/android/provider/Settings.java
+++ b/core/java/android/provider/Settings.java
@@ -4427,6 +4427,18 @@ public final class Settings {
          * the setting value. See an example above.
          */
 
+        /**
+         * Enable statusbar double tap gesture on to put device to sleep
+         * @hide
+         */
+        public static final String DOUBLE_TAP_SLEEP_GESTURE = "double_tap_sleep_gesture";
+
+        /**
+         * Enable double tap gesture anywhere on the lock screen put device to sleep
+         * @hide
+         */
+        public static final String DOUBLE_TAP_SLEEP_LOCKSCREEN = "double_tap_sleep_lockscreen";
+
         /**
          * Settings to backup. This is here so that it's in the same place as the settings
          * keys and easy to update.
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
index 5c18782727d..4e4d9e5b361 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/NotificationPanelView.java
@@ -25,21 +25,28 @@ import android.animation.ValueAnimator;
 import android.app.ActivityManager;
 import android.app.Fragment;
 import android.app.StatusBarManager;
+import android.content.ContentResolver;
 import android.content.Context;
 import android.content.pm.ResolveInfo;
 import android.content.res.Configuration;
 import android.content.res.Resources;
+import android.database.ContentObserver;
 import android.graphics.Canvas;
 import android.graphics.Color;
 import android.graphics.Paint;
 import android.graphics.PorterDuff;
 import android.graphics.PorterDuffXfermode;
 import android.graphics.Rect;
+import android.net.Uri;
+import android.os.Handler;
 import android.os.PowerManager;
+import android.os.UserHandle;
+import android.provider.Settings;
 import android.util.AttributeSet;
 import android.util.FloatProperty;
 import android.util.Log;
 import android.util.MathUtils;
+import android.view.GestureDetector;
 import android.view.LayoutInflater;
 import android.view.MotionEvent;
 import android.view.VelocityTracker;
@@ -82,15 +89,15 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.function.Consumer;
 
-public class NotificationPanelView extends PanelView implements
-        ExpandableView.OnHeightChangedListener,
-        View.OnClickListener, NotificationStackScrollLayout.OnOverscrollTopChangedListener,
-        KeyguardAffordanceHelper.Callback, NotificationStackScrollLayout.OnEmptySpaceClickListener,
-        OnHeadsUpChangedListener, QS.HeightListener {
+public class NotificationPanelView extends PanelView
+        implements ExpandableView.OnHeightChangedListener, View.OnClickListener,
+        NotificationStackScrollLayout.OnOverscrollTopChangedListener, KeyguardAffordanceHelper.Callback,
+        NotificationStackScrollLayout.OnEmptySpaceClickListener, OnHeadsUpChangedListener, QS.HeightListener {
 
     private static final boolean DEBUG = false;
 
-    // Cap and total height of Roboto font. Needs to be adjusted when font for the big clock is
+    // Cap and total height of Roboto font. Needs to be adjusted when font for the
+    // big clock is
     // changed.
     private static final int CAP_HEIGHT = 1456;
     private static final int FONT_HEIGHT = 2163;
@@ -107,19 +114,19 @@ public class NotificationPanelView extends PanelView implements
 
     private static final AnimationProperties CLOCK_ANIMATION_PROPERTIES = new AnimationProperties()
             .setDuration(StackStateAnimator.ANIMATION_DURATION_STANDARD);
-    private static final FloatProperty<NotificationPanelView> SET_DARK_AMOUNT_PROPERTY =
-            new FloatProperty<NotificationPanelView>("mInterpolatedDarkAmount") {
+    private static final FloatProperty<NotificationPanelView> SET_DARK_AMOUNT_PROPERTY = new FloatProperty<NotificationPanelView>(
+            "mInterpolatedDarkAmount") {
 
-                @Override
-                public void setValue(NotificationPanelView object, float value) {
-                    object.setDarkAmount(value, object.mDarkInterpolator.getInterpolation(value));
-                }
+        @Override
+        public void setValue(NotificationPanelView object, float value) {
+            object.setDarkAmount(value, object.mDarkInterpolator.getInterpolation(value));
+        }
 
-                @Override
-                public Float get(NotificationPanelView object) {
-                    return object.mLinearDarkAmount;
-                }
-            };
+        @Override
+        public Float get(NotificationPanelView object) {
+            return object.mLinearDarkAmount;
+        }
+    };
 
     private Interpolator mDarkInterpolator;
     private final PowerManager mPowerManager;
@@ -141,14 +148,14 @@ public class NotificationPanelView extends PanelView implements
     private boolean mQsTracking;
 
     /**
-     * If set, the ongoing touch gesture might both trigger the expansion in {@link PanelView} and
-     * the expansion for quick settings.
+     * If set, the ongoing touch gesture might both trigger the expansion in
+     * {@link PanelView} and the expansion for quick settings.
      */
     private boolean mConflictingQsExpansionGesture;
 
     /**
-     * Whether we are currently handling a motion gesture in #onInterceptTouchEvent, but haven't
-     * intercepted yet.
+     * Whether we are currently handling a motion gesture in #onInterceptTouchEvent,
+     * but haven't intercepted yet.
      */
     private boolean mIntercepting;
     private boolean mPanelExpanded;
@@ -181,10 +188,8 @@ public class NotificationPanelView extends PanelView implements
     private int mUnlockMoveDistance;
     private float mEmptyDragAmount;
 
-    private KeyguardClockPositionAlgorithm mClockPositionAlgorithm =
-            new KeyguardClockPositionAlgorithm();
-    private KeyguardClockPositionAlgorithm.Result mClockPositionResult =
-            new KeyguardClockPositionAlgorithm.Result();
+    private KeyguardClockPositionAlgorithm mClockPositionAlgorithm = new KeyguardClockPositionAlgorithm();
+    private KeyguardClockPositionAlgorithm.Result mClockPositionResult = new KeyguardClockPositionAlgorithm.Result();
     private boolean mIsExpanding;
 
     private boolean mBlockTouches;
@@ -193,8 +198,8 @@ public class NotificationPanelView extends PanelView implements
     private boolean mTwoFingerQsExpandPossible;
 
     /**
-     * If we are in a panel collapsing motion, we reset scrollY of our scroll view but still
-     * need to take this into account in our panel height calculation.
+     * If we are in a panel collapsing motion, we reset scrollY of our scroll view
+     * but still need to take this into account in our panel height calculation.
      */
     private boolean mQsAnimatorExpand;
     private boolean mIsLaunchTransitionFinished;
@@ -248,8 +253,8 @@ public class NotificationPanelView extends PanelView implements
     private float mInterpolatedDarkAmount;
 
     /**
-     * Dark amount that animates from 0 to 1 or vice-versa in linear manner, even if the
-     * interpolation curve is different.
+     * Dark amount that animates from 0 to 1 or vice-versa in linear manner, even if
+     * the interpolation curve is different.
      */
     private float mLinearDarkAmount;
 
@@ -263,8 +268,7 @@ public class NotificationPanelView extends PanelView implements
     private float mExpandOffset;
     private boolean mHideIconsDuringNotificationLaunch = true;
     private int mStackScrollerMeasuringPass;
-    private ArrayList<Consumer<ExpandableNotificationRow>> mTrackingHeadsUpListeners
-            = new ArrayList<>();
+    private ArrayList<Consumer<ExpandableNotificationRow>> mTrackingHeadsUpListeners = new ArrayList<>();
     private ArrayList<Runnable> mVerticalTranslationListener = new ArrayList<>();
     private HeadsUpAppearanceController mHeadsUpAppearanceController;
 
@@ -280,21 +284,22 @@ public class NotificationPanelView extends PanelView implements
             }
         }
     };
-    private final AnimatableProperty PANEL_ALPHA = AnimatableProperty.from(
-            "panelAlpha",
-            NotificationPanelView::setPanelAlphaInternal,
-            NotificationPanelView::getCurrentPanelAlpha,
-            R.id.panel_alpha_animator_tag,
-            R.id.panel_alpha_animator_start_tag,
-            R.id.panel_alpha_animator_end_tag);
-    private final AnimationProperties PANEL_ALPHA_OUT_PROPERTIES = new AnimationProperties()
-            .setDuration(150)
+    private final AnimatableProperty PANEL_ALPHA = AnimatableProperty.from("panelAlpha",
+            NotificationPanelView::setPanelAlphaInternal, NotificationPanelView::getCurrentPanelAlpha,
+            R.id.panel_alpha_animator_tag, R.id.panel_alpha_animator_start_tag, R.id.panel_alpha_animator_end_tag);
+    private final AnimationProperties PANEL_ALPHA_OUT_PROPERTIES = new AnimationProperties().setDuration(150)
             .setCustomInterpolator(PANEL_ALPHA.getProperty(), Interpolators.ALPHA_OUT);
-    private final AnimationProperties PANEL_ALPHA_IN_PROPERTIES = new AnimationProperties()
-            .setDuration(200)
+    private final AnimationProperties PANEL_ALPHA_IN_PROPERTIES = new AnimationProperties().setDuration(200)
             .setAnimationFinishListener(mAnimatorListenerAdapter)
             .setCustomInterpolator(PANEL_ALPHA.getProperty(), Interpolators.ALPHA_IN);
 
+    private boolean mDoubleTapToSleepEnabled;
+    private boolean mDoubleTapToSleepAnywhere;
+    private int mStatusBarHeaderHeight;
+    private GestureDetector mDoubleTapGesture;
+    private Handler mHandler = new Handler();
+    private SettingsObserver mSettingsObserver;
+
     public NotificationPanelView(Context context, AttributeSet attrs) {
         super(context, attrs);
         setWillNotDraw(!DEBUG);
@@ -304,6 +309,16 @@ public class NotificationPanelView extends PanelView implements
         setAccessibilityPaneTitle(determineAccessibilityPaneTitle());
         mAlphaPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY));
         setPanelAlpha(255, false /* animate */);
+        mSettingsObserver = new SettingsObserver(mHandler);
+        mDoubleTapGesture = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {
+            @Override
+            public boolean onDoubleTap(MotionEvent e) {
+                PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+                if (pm != null)
+                    pm.goToSleep(e.getEventTime());
+                return true;
+            }
+        });
     }
 
     public void setStatusBar(StatusBar bar) {
@@ -348,31 +363,24 @@ public class NotificationPanelView extends PanelView implements
     protected void loadDimens() {
         super.loadDimens();
         mFlingAnimationUtils = new FlingAnimationUtils(getContext(), 0.4f);
-        mStatusBarMinHeight = getResources().getDimensionPixelSize(
-                com.android.internal.R.dimen.status_bar_height);
+        mStatusBarMinHeight = getResources().getDimensionPixelSize(com.android.internal.R.dimen.status_bar_height);
         mQsPeekHeight = getResources().getDimensionPixelSize(R.dimen.qs_peek_height);
-        mNotificationsHeaderCollideDistance =
-                getResources().getDimensionPixelSize(R.dimen.header_notifications_collide_distance);
+        mNotificationsHeaderCollideDistance = getResources()
+                .getDimensionPixelSize(R.dimen.header_notifications_collide_distance);
         mUnlockMoveDistance = getResources().getDimensionPixelOffset(R.dimen.unlock_move_distance);
         mClockPositionAlgorithm.loadDimens(getResources());
-        mQsFalsingThreshold = getResources().getDimensionPixelSize(
-                R.dimen.qs_falsing_threshold);
-        mPositionMinSideMargin = getResources().getDimensionPixelSize(
-                R.dimen.notification_panel_min_side_margin);
-        mMaxFadeoutHeight = getResources().getDimensionPixelSize(
-                R.dimen.max_notification_fadeout_height);
-        mIndicationBottomPadding = getResources().getDimensionPixelSize(
-                R.dimen.keyguard_indication_bottom_padding);
-        mQsNotificationTopPadding = getResources().getDimensionPixelSize(
-                R.dimen.qs_notification_padding);
+        mQsFalsingThreshold = getResources().getDimensionPixelSize(R.dimen.qs_falsing_threshold);
+        mPositionMinSideMargin = getResources().getDimensionPixelSize(R.dimen.notification_panel_min_side_margin);
+        mMaxFadeoutHeight = getResources().getDimensionPixelSize(R.dimen.max_notification_fadeout_height);
+        mIndicationBottomPadding = getResources().getDimensionPixelSize(R.dimen.keyguard_indication_bottom_padding);
+        mQsNotificationTopPadding = getResources().getDimensionPixelSize(R.dimen.qs_notification_padding);
     }
 
     public void updateResources() {
         Resources res = getResources();
         int qsWidth = res.getDimensionPixelSize(R.dimen.qs_panel_width);
         int panelGravity = getResources().getInteger(R.integer.notification_panel_layout_gravity);
-        FrameLayout.LayoutParams lp =
-                (FrameLayout.LayoutParams) mQsFrame.getLayoutParams();
+        FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mQsFrame.getLayoutParams();
         if (lp.width != qsWidth || lp.gravity != panelGravity) {
             lp.width = qsWidth;
             lp.gravity = panelGravity;
@@ -392,19 +400,15 @@ public class NotificationPanelView extends PanelView implements
         // Re-inflate the status view group.
         int index = indexOfChild(mKeyguardStatusView);
         removeView(mKeyguardStatusView);
-        mKeyguardStatusView = (KeyguardStatusView) LayoutInflater.from(mContext).inflate(
-                R.layout.keyguard_status_view,
-                this,
-                false);
+        mKeyguardStatusView = (KeyguardStatusView) LayoutInflater.from(mContext).inflate(R.layout.keyguard_status_view,
+                this, false);
         addView(mKeyguardStatusView, index);
 
         // Update keyguard bottom area
         index = indexOfChild(mKeyguardBottomArea);
         removeView(mKeyguardBottomArea);
-        mKeyguardBottomArea = (KeyguardBottomAreaView) LayoutInflater.from(mContext).inflate(
-                R.layout.keyguard_bottom_area,
-                this,
-                false);
+        mKeyguardBottomArea = (KeyguardBottomAreaView) LayoutInflater.from(mContext)
+                .inflate(R.layout.keyguard_bottom_area, this, false);
         addView(mKeyguardBottomArea, index);
         initBottomArea();
         setDarkAmount(mLinearDarkAmount, mInterpolatedDarkAmount);
@@ -431,16 +435,14 @@ public class NotificationPanelView extends PanelView implements
 
         // Update Clock Pivot
         mKeyguardStatusView.setPivotX(getWidth() / 2);
-        mKeyguardStatusView.setPivotY((FONT_HEIGHT - CAP_HEIGHT) / 2048f *
-                mKeyguardStatusView.getClockTextSize());
+        mKeyguardStatusView.setPivotY((FONT_HEIGHT - CAP_HEIGHT) / 2048f * mKeyguardStatusView.getClockTextSize());
 
         // Calculate quick setting heights.
         int oldMaxHeight = mQsMaxExpansionHeight;
         if (mQs != null) {
             mQsMinExpansionHeight = mKeyguardShowing ? 0 : mQs.getQsMinExpansionHeight();
             mQsMaxExpansionHeight = mQs.getDesiredHeight();
-            mNotificationStackScroller.setMaxTopPadding(
-                    mQsMaxExpansionHeight + mQsNotificationTopPadding);
+            mNotificationStackScroller.setMaxTopPadding(mQsMaxExpansionHeight + mQsNotificationTopPadding);
         }
         positionClockAndNotifications();
         if (mQsExpanded && mQsFullyExpanded) {
@@ -458,10 +460,14 @@ public class NotificationPanelView extends PanelView implements
         updateExpandedHeight(getExpandedHeight());
         updateHeader();
 
-        // If we are running a size change animation, the animation takes care of the height of
-        // the container. However, if we are not animating, we always need to make the QS container
-        // the desired height so when closing the QS detail, it stays smaller after the size change
-        // animation is finished but the detail view is still being animated away (this animation
+        // If we are running a size change animation, the animation takes care of the
+        // height of
+        // the container. However, if we are not animating, we always need to make the
+        // QS container
+        // the desired height so when closing the QS detail, it stays smaller after the
+        // size change
+        // animation is finished but the detail view is still being animated away (this
+        // animation
         // takes longer than the size change animation).
         if (mQsSizeChangeAnimator == null && mQs != null) {
             mQs.setHeightOverride(mQs.getDesiredHeight());
@@ -501,8 +507,8 @@ public class NotificationPanelView extends PanelView implements
     }
 
     /**
-     * Positions the clock and notifications dynamically depending on how many notifications are
-     * showing.
+     * Positions the clock and notifications dynamically depending on how many
+     * notifications are showing.
      */
     private void positionClockAndNotifications() {
         boolean animate = mNotificationStackScroller.isAddOrRemoveAnimationPending();
@@ -510,26 +516,19 @@ public class NotificationPanelView extends PanelView implements
         int stackScrollerPadding;
         if (mStatusBarState != StatusBarState.KEYGUARD) {
             stackScrollerPadding = (mQs != null ? mQs.getHeader().getHeight() : 0) + mQsPeekHeight
-            +  mQsNotificationTopPadding;
+                    + mQsNotificationTopPadding;
         } else {
             int totalHeight = getHeight();
             int bottomPadding = Math.max(mIndicationBottomPadding, mAmbientIndicationBottomPadding);
-            mClockPositionAlgorithm.setup(
-                    mStatusBarMinHeight,
-                    totalHeight - bottomPadding,
-                    mNotificationStackScroller.getIntrinsicContentHeight(),
-                    getExpandedFraction(),
-                    totalHeight,
-                    mKeyguardStatusView.getHeight(),
-                    mInterpolatedDarkAmount,
-                    mStatusBar.isKeyguardCurrentlySecure(),
-                    mPulsing,
-                    mBouncerTop);
+            mClockPositionAlgorithm.setup(mStatusBarMinHeight, totalHeight - bottomPadding,
+                    mNotificationStackScroller.getIntrinsicContentHeight(), getExpandedFraction(), totalHeight,
+                    mKeyguardStatusView.getHeight(), mInterpolatedDarkAmount, mStatusBar.isKeyguardCurrentlySecure(),
+                    mPulsing, mBouncerTop);
             mClockPositionAlgorithm.run(mClockPositionResult);
-            PropertyAnimator.setProperty(mKeyguardStatusView, AnimatableProperty.X,
-                    mClockPositionResult.clockX, CLOCK_ANIMATION_PROPERTIES, animateClock);
-            PropertyAnimator.setProperty(mKeyguardStatusView, AnimatableProperty.Y,
-                    mClockPositionResult.clockY, CLOCK_ANIMATION_PROPERTIES, animateClock);
+            PropertyAnimator.setProperty(mKeyguardStatusView, AnimatableProperty.X, mClockPositionResult.clockX,
+                    CLOCK_ANIMATION_PROPERTIES, animateClock);
+            PropertyAnimator.setProperty(mKeyguardStatusView, AnimatableProperty.Y, mClockPositionResult.clockY,
+                    CLOCK_ANIMATION_PROPERTIES, animateClock);
             updateClock();
             stackScrollerPadding = mClockPositionResult.stackScrollerPadding;
         }
@@ -549,11 +548,10 @@ public class NotificationPanelView extends PanelView implements
      */
     public int computeMaxKeyguardNotifications(int maximum) {
         float minPadding = mClockPositionAlgorithm.getMinStackScrollerPadding();
-        int notificationPadding = Math.max(1, getResources().getDimensionPixelSize(
-                R.dimen.notification_divider_height));
+        int notificationPadding = Math.max(1,
+                getResources().getDimensionPixelSize(R.dimen.notification_divider_height));
         NotificationShelf shelf = mNotificationStackScroller.getNotificationShelf();
-        float shelfSize = shelf.getVisibility() == GONE ? 0
-                : shelf.getIntrinsicHeight() + notificationPadding;
+        float shelfSize = shelf.getVisibility() == GONE ? 0 : shelf.getIntrinsicHeight() + notificationPadding;
         float availableSpace = mNotificationStackScroller.getHeight() - minPadding - shelfSize
                 - Math.max(mIndicationBottomPadding, mAmbientIndicationBottomPadding)
                 - mKeyguardStatusView.getLogoutButtonHeight();
@@ -564,27 +562,24 @@ public class NotificationPanelView extends PanelView implements
                 continue;
             }
             ExpandableNotificationRow row = (ExpandableNotificationRow) child;
-            boolean suppressedSummary = mGroupManager.isSummaryOfSuppressedGroup(
-                    row.getStatusBarNotification());
+            boolean suppressedSummary = mGroupManager.isSummaryOfSuppressedGroup(row.getStatusBarNotification());
             if (suppressedSummary) {
                 continue;
             }
-            if (!mStatusBar.getNotificationLockscreenUserManager().shouldShowOnKeyguard(
-                    row.getStatusBarNotification())) {
+            if (!mStatusBar.getNotificationLockscreenUserManager()
+                    .shouldShowOnKeyguard(row.getStatusBarNotification())) {
                 continue;
             }
             if (row.isRemoved()) {
                 continue;
             }
-            availableSpace -= child.getMinHeight(true /* ignoreTemporaryStates */)
-                    + notificationPadding;
+            availableSpace -= child.getMinHeight(true /* ignoreTemporaryStates */) + notificationPadding;
             if (availableSpace >= 0 && count < maximum) {
                 count++;
             } else if (availableSpace > -shelfSize) {
                 // if we are exactly the last view, then we can show us still!
                 for (int j = i + 1; j < mNotificationStackScroller.getChildCount(); j++) {
-                    if (mNotificationStackScroller.getChildAt(j)
-                            instanceof ExpandableNotificationRow) {
+                    if (mNotificationStackScroller.getChildAt(j) instanceof ExpandableNotificationRow) {
                         return count;
                     }
                 }
@@ -616,7 +611,8 @@ public class NotificationPanelView extends PanelView implements
 
     public void setQsExpansionEnabled(boolean qsExpansionEnabled) {
         mQsExpansionEnabled = qsExpansionEnabled;
-        if (mQs == null) return;
+        if (mQs == null)
+            return;
         mQs.setHeaderClickable(qsExpansionEnabled);
     }
 
@@ -630,8 +626,8 @@ public class NotificationPanelView extends PanelView implements
             mLastCameraLaunchSource = KeyguardBottomAreaView.CAMERA_LAUNCH_SOURCE_AFFORDANCE;
         }
         closeQs();
-        mStatusBar.getGutsManager().closeAndSaveGuts(true /* leavebehind */, true /* force */,
-                true /* controls */, -1 /* x */, -1 /* y */, true /* resetMenu */);
+        mStatusBar.getGutsManager().closeAndSaveGuts(true /* leavebehind */, true /* force */, true /* controls */,
+                -1 /* x */, -1 /* y */, true /* resetMenu */);
         mNotificationStackScroller.setOverScrollAmount(0f, true /* onTop */, false /* animate */,
                 true /* cancelAnimators */);
         mNotificationStackScroller.resetScrollPosition();
@@ -700,8 +696,8 @@ public class NotificationPanelView extends PanelView implements
     }
 
     @Override
-    protected void flingToHeight(float vel, boolean expand, float target,
-            float collapseSpeedUpFactor, boolean expandBecauseOfFalsing) {
+    protected void flingToHeight(float vel, boolean expand, float target, float collapseSpeedUpFactor,
+            boolean expandBecauseOfFalsing) {
         mHeadsUpTouchHelper.notifyFling(!expand);
         setClosingWithAlphaFadeout(!expand && getFadeoutAlpha() == 1.0f);
         super.flingToHeight(vel, expand, target, collapseSpeedUpFactor, expandBecauseOfFalsing);
@@ -736,71 +732,70 @@ public class NotificationPanelView extends PanelView implements
         final float y = event.getY(pointerIndex);
 
         switch (event.getActionMasked()) {
-            case MotionEvent.ACTION_DOWN:
-                mIntercepting = true;
-                mInitialTouchY = y;
-                mInitialTouchX = x;
-                initVelocityTracker();
-                trackMovement(event);
-                if (shouldQuickSettingsIntercept(mInitialTouchX, mInitialTouchY, 0)) {
-                    getParent().requestDisallowInterceptTouchEvent(true);
-                }
-                if (mQsExpansionAnimator != null) {
-                    onQsExpansionStarted();
-                    mInitialHeightOnTouch = mQsExpansionHeight;
-                    mQsTracking = true;
-                    mIntercepting = false;
-                    mNotificationStackScroller.cancelLongPress();
-                }
-                break;
-            case MotionEvent.ACTION_POINTER_UP:
-                final int upPointer = event.getPointerId(event.getActionIndex());
-                if (mTrackingPointer == upPointer) {
-                    // gesture is ongoing, find a new pointer to track
-                    final int newIndex = event.getPointerId(0) != upPointer ? 0 : 1;
-                    mTrackingPointer = event.getPointerId(newIndex);
-                    mInitialTouchX = event.getX(newIndex);
-                    mInitialTouchY = event.getY(newIndex);
-                }
-                break;
+        case MotionEvent.ACTION_DOWN:
+            mIntercepting = true;
+            mInitialTouchY = y;
+            mInitialTouchX = x;
+            initVelocityTracker();
+            trackMovement(event);
+            if (shouldQuickSettingsIntercept(mInitialTouchX, mInitialTouchY, 0)) {
+                getParent().requestDisallowInterceptTouchEvent(true);
+            }
+            if (mQsExpansionAnimator != null) {
+                onQsExpansionStarted();
+                mInitialHeightOnTouch = mQsExpansionHeight;
+                mQsTracking = true;
+                mIntercepting = false;
+                mNotificationStackScroller.cancelLongPress();
+            }
+            break;
+        case MotionEvent.ACTION_POINTER_UP:
+            final int upPointer = event.getPointerId(event.getActionIndex());
+            if (mTrackingPointer == upPointer) {
+                // gesture is ongoing, find a new pointer to track
+                final int newIndex = event.getPointerId(0) != upPointer ? 0 : 1;
+                mTrackingPointer = event.getPointerId(newIndex);
+                mInitialTouchX = event.getX(newIndex);
+                mInitialTouchY = event.getY(newIndex);
+            }
+            break;
 
-            case MotionEvent.ACTION_MOVE:
-                final float h = y - mInitialTouchY;
-                trackMovement(event);
-                if (mQsTracking) {
-
-                    // Already tracking because onOverscrolled was called. We need to update here
-                    // so we don't stop for a frame until the next touch event gets handled in
-                    // onTouchEvent.
-                    setQsExpansion(h + mInitialHeightOnTouch);
-                    trackMovement(event);
-                    mIntercepting = false;
-                    return true;
-                }
-                if (Math.abs(h) > mTouchSlop && Math.abs(h) > Math.abs(x - mInitialTouchX)
-                        && shouldQuickSettingsIntercept(mInitialTouchX, mInitialTouchY, h)) {
-                    mQsTracking = true;
-                    onQsExpansionStarted();
-                    notifyExpandingFinished();
-                    mInitialHeightOnTouch = mQsExpansionHeight;
-                    mInitialTouchY = y;
-                    mInitialTouchX = x;
-                    mIntercepting = false;
-                    mNotificationStackScroller.cancelLongPress();
-                    return true;
-                }
-                break;
+        case MotionEvent.ACTION_MOVE:
+            final float h = y - mInitialTouchY;
+            trackMovement(event);
+            if (mQsTracking) {
 
-            case MotionEvent.ACTION_CANCEL:
-            case MotionEvent.ACTION_UP:
+                // Already tracking because onOverscrolled was called. We need to update here
+                // so we don't stop for a frame until the next touch event gets handled in
+                // onTouchEvent.
+                setQsExpansion(h + mInitialHeightOnTouch);
                 trackMovement(event);
-                if (mQsTracking) {
-                    flingQsWithCurrentVelocity(y,
-                            event.getActionMasked() == MotionEvent.ACTION_CANCEL);
-                    mQsTracking = false;
-                }
                 mIntercepting = false;
-                break;
+                return true;
+            }
+            if (Math.abs(h) > mTouchSlop && Math.abs(h) > Math.abs(x - mInitialTouchX)
+                    && shouldQuickSettingsIntercept(mInitialTouchX, mInitialTouchY, h)) {
+                mQsTracking = true;
+                onQsExpansionStarted();
+                notifyExpandingFinished();
+                mInitialHeightOnTouch = mQsExpansionHeight;
+                mInitialTouchY = y;
+                mInitialTouchX = x;
+                mIntercepting = false;
+                mNotificationStackScroller.cancelLongPress();
+                return true;
+            }
+            break;
+
+        case MotionEvent.ACTION_CANCEL:
+        case MotionEvent.ACTION_UP:
+            trackMovement(event);
+            if (mQsTracking) {
+                flingQsWithCurrentVelocity(y, event.getActionMasked() == MotionEvent.ACTION_CANCEL);
+                mQsTracking = false;
+            }
+            mIntercepting = false;
+            break;
         }
         return false;
     }
@@ -808,8 +803,8 @@ public class NotificationPanelView extends PanelView implements
     @Override
     protected boolean isInContentBounds(float x, float y) {
         float stackScrollerX = mNotificationStackScroller.getX();
-        return !mNotificationStackScroller.isBelowLastNotification(x - stackScrollerX, y)
-                && stackScrollerX < x && x < stackScrollerX + mNotificationStackScroller.getWidth();
+        return !mNotificationStackScroller.isBelowLastNotification(x - stackScrollerX, y) && stackScrollerX < x
+                && x < stackScrollerX + mNotificationStackScroller.getWidth();
     }
 
     private void initDownStates(MotionEvent event) {
@@ -833,11 +828,9 @@ public class NotificationPanelView extends PanelView implements
 
     private void logQsSwipeDown(float y) {
         float vel = getCurrentQSVelocity();
-        final int gesture = mStatusBarState == StatusBarState.KEYGUARD
-                ? MetricsEvent.ACTION_LS_QS
+        final int gesture = mStatusBarState == StatusBarState.KEYGUARD ? MetricsEvent.ACTION_LS_QS
                 : MetricsEvent.ACTION_SHADE_QS_PULL;
-        mLockscreenGestureLogger.write(gesture,
-                (int) ((y - mInitialTouchY) / mStatusBar.getDisplayDensity()),
+        mLockscreenGestureLogger.write(gesture, (int) ((y - mInitialTouchY) / mStatusBar.getDisplayDensity()),
                 (int) (vel / mStatusBar.getDisplayDensity()));
     }
 
@@ -863,8 +856,8 @@ public class NotificationPanelView extends PanelView implements
     }
 
     private float getQsExpansionFraction() {
-        return Math.min(1f, (mQsExpansionHeight - mQsMinExpansionHeight)
-                / (mQsMaxExpansionHeight - mQsMinExpansionHeight));
+        return Math.min(1f,
+                (mQsExpansionHeight - mQsMinExpansionHeight) / (mQsMaxExpansionHeight - mQsMinExpansionHeight));
     }
 
     @Override
@@ -877,6 +870,12 @@ public class NotificationPanelView extends PanelView implements
         if (mBlockTouches || (mQs != null && mQs.isCustomizing())) {
             return false;
         }
+        if (mDoubleTapToSleepEnabled && mStatusBarState == StatusBarState.KEYGUARD
+                && event.getY() < mStatusBarHeaderHeight) {
+            mDoubleTapGesture.onTouchEvent(event);
+        } else if (mDoubleTapToSleepAnywhere && mStatusBarState == StatusBarState.KEYGUARD) {
+            mDoubleTapGesture.onTouchEvent(event);
+        }
         initDownStates(event);
         if (mListenForHeadsUp && !mHeadsUpTouchHelper.isTrackingHeadsUp()
                 && mHeadsUpTouchHelper.onInterceptTouchEvent(event)) {
@@ -884,9 +883,7 @@ public class NotificationPanelView extends PanelView implements
             MetricsLogger.count(mContext, COUNTER_PANEL_OPEN_PEEK, 1);
         }
         boolean handled = false;
-        if ((!mIsExpanding || mHintAnimationRunning)
-                && !mQsExpanded
-                && mStatusBar.getBarState() != StatusBarState.SHADE
+        if ((!mIsExpanding || mHintAnimationRunning) && !mQsExpanded && mStatusBar.getBarState() != StatusBarState.SHADE
                 && !mDozing) {
             handled |= mAffordanceHelper.onTouchEvent(event);
         }
@@ -910,8 +907,7 @@ public class NotificationPanelView extends PanelView implements
     private boolean handleQsTouch(MotionEvent event) {
         final int action = event.getActionMasked();
         if (action == MotionEvent.ACTION_DOWN && getExpandedFraction() == 1f
-                && mStatusBar.getBarState() != StatusBarState.KEYGUARD && !mQsExpanded
-                && mQsExpansionEnabled) {
+                && mStatusBar.getBarState() != StatusBarState.KEYGUARD && !mQsExpanded && mQsExpansionEnabled) {
 
             // Down in the empty area while fully expanded - go to QS.
             mQsTracking = true;
@@ -933,8 +929,7 @@ public class NotificationPanelView extends PanelView implements
         if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
             mConflictingQsExpansionGesture = false;
         }
-        if (action == MotionEvent.ACTION_DOWN && isFullyCollapsed()
-                && mQsExpansionEnabled) {
+        if (action == MotionEvent.ACTION_DOWN && isFullyCollapsed() && mQsExpansionEnabled) {
             mTwoFingerQsExpandPossible = true;
         }
         if (mTwoFingerQsExpandPossible && isOpenQsEvent(event)
@@ -944,7 +939,8 @@ public class NotificationPanelView extends PanelView implements
             mNotificationStackScroller.setShouldShowShelfOnly(true);
             requestPanelHeightUpdate();
 
-            // Normally, we start listening when the panel is expanded, but here we need to start
+            // Normally, we start listening when the panel is expanded, but here we need to
+            // start
             // earlier so the state is already up to date when dragging down.
             setListening(true);
         }
@@ -952,18 +948,16 @@ public class NotificationPanelView extends PanelView implements
     }
 
     private boolean isInQsArea(float x, float y) {
-        return (x >= mQsFrame.getX()
-                && x <= mQsFrame.getX() + mQsFrame.getWidth())
+        return (x >= mQsFrame.getX() && x <= mQsFrame.getX() + mQsFrame.getWidth())
                 && (y <= mNotificationStackScroller.getBottomMostNotificationBottom()
-                || y <= mQs.getView().getY() + mQs.getView().getHeight());
+                        || y <= mQs.getView().getY() + mQs.getView().getHeight());
     }
 
     private boolean isOpenQsEvent(MotionEvent event) {
         final int pointerCount = event.getPointerCount();
         final int action = event.getActionMasked();
 
-        final boolean twoFingerDrag = action == MotionEvent.ACTION_POINTER_DOWN
-                && pointerCount == 2;
+        final boolean twoFingerDrag = action == MotionEvent.ACTION_POINTER_DOWN && pointerCount == 2;
 
         final boolean stylusButtonClickDrag = action == MotionEvent.ACTION_DOWN
                 && (event.isButtonPressed(MotionEvent.BUTTON_STYLUS_PRIMARY)
@@ -986,7 +980,8 @@ public class NotificationPanelView extends PanelView implements
             mInitialTouchY = event.getX();
             mInitialTouchX = event.getY();
 
-            // If we interrupt an expansion gesture here, make sure to update the state correctly.
+            // If we interrupt an expansion gesture here, make sure to update the state
+            // correctly.
             notifyExpandingFinished();
         }
     }
@@ -995,7 +990,8 @@ public class NotificationPanelView extends PanelView implements
     protected boolean flingExpands(float vel, float vectorVel, float x, float y) {
         boolean expands = super.flingExpands(vel, vectorVel, x, y);
 
-        // If we are already running a QS expansion, make sure that we keep the panel open.
+        // If we are already running a QS expansion, make sure that we keep the panel
+        // open.
         if (mQsExpansionAnimator != null) {
             expands = true;
         }
@@ -1023,53 +1019,52 @@ public class NotificationPanelView extends PanelView implements
         final float h = y - mInitialTouchY;
 
         switch (event.getActionMasked()) {
-            case MotionEvent.ACTION_DOWN:
-                mQsTracking = true;
-                mInitialTouchY = y;
-                mInitialTouchX = x;
-                onQsExpansionStarted();
+        case MotionEvent.ACTION_DOWN:
+            mQsTracking = true;
+            mInitialTouchY = y;
+            mInitialTouchX = x;
+            onQsExpansionStarted();
+            mInitialHeightOnTouch = mQsExpansionHeight;
+            initVelocityTracker();
+            trackMovement(event);
+            break;
+
+        case MotionEvent.ACTION_POINTER_UP:
+            final int upPointer = event.getPointerId(event.getActionIndex());
+            if (mTrackingPointer == upPointer) {
+                // gesture is ongoing, find a new pointer to track
+                final int newIndex = event.getPointerId(0) != upPointer ? 0 : 1;
+                final float newY = event.getY(newIndex);
+                final float newX = event.getX(newIndex);
+                mTrackingPointer = event.getPointerId(newIndex);
                 mInitialHeightOnTouch = mQsExpansionHeight;
-                initVelocityTracker();
-                trackMovement(event);
-                break;
-
-            case MotionEvent.ACTION_POINTER_UP:
-                final int upPointer = event.getPointerId(event.getActionIndex());
-                if (mTrackingPointer == upPointer) {
-                    // gesture is ongoing, find a new pointer to track
-                    final int newIndex = event.getPointerId(0) != upPointer ? 0 : 1;
-                    final float newY = event.getY(newIndex);
-                    final float newX = event.getX(newIndex);
-                    mTrackingPointer = event.getPointerId(newIndex);
-                    mInitialHeightOnTouch = mQsExpansionHeight;
-                    mInitialTouchY = newY;
-                    mInitialTouchX = newX;
-                }
-                break;
-
-            case MotionEvent.ACTION_MOVE:
-                setQsExpansion(h + mInitialHeightOnTouch);
-                if (h >= getFalsingThreshold()) {
-                    mQsTouchAboveFalsingThreshold = true;
-                }
-                trackMovement(event);
-                break;
+                mInitialTouchY = newY;
+                mInitialTouchX = newX;
+            }
+            break;
 
-            case MotionEvent.ACTION_UP:
-            case MotionEvent.ACTION_CANCEL:
-                mQsTracking = false;
-                mTrackingPointer = -1;
-                trackMovement(event);
-                float fraction = getQsExpansionFraction();
-                if (fraction != 0f || y >= mInitialTouchY) {
-                    flingQsWithCurrentVelocity(y,
-                            event.getActionMasked() == MotionEvent.ACTION_CANCEL);
-                }
-                if (mQsVelocityTracker != null) {
-                    mQsVelocityTracker.recycle();
-                    mQsVelocityTracker = null;
-                }
-                break;
+        case MotionEvent.ACTION_MOVE:
+            setQsExpansion(h + mInitialHeightOnTouch);
+            if (h >= getFalsingThreshold()) {
+                mQsTouchAboveFalsingThreshold = true;
+            }
+            trackMovement(event);
+            break;
+
+        case MotionEvent.ACTION_UP:
+        case MotionEvent.ACTION_CANCEL:
+            mQsTracking = false;
+            mTrackingPointer = -1;
+            trackMovement(event);
+            float fraction = getQsExpansionFraction();
+            if (fraction != 0f || y >= mInitialTouchY) {
+                flingQsWithCurrentVelocity(y, event.getActionMasked() == MotionEvent.ACTION_CANCEL);
+            }
+            if (mQsVelocityTracker != null) {
+                mQsVelocityTracker.recycle();
+                mQsVelocityTracker = null;
+            }
+            break;
         }
     }
 
@@ -1097,20 +1092,20 @@ public class NotificationPanelView extends PanelView implements
         mLastOverscroll = 0f;
         mQsExpansionFromOverscroll = false;
         setQsExpansion(mQsExpansionHeight);
-        flingSettings(!mQsExpansionEnabled && open ? 0f : velocity, open && mQsExpansionEnabled,
-                new Runnable() {
-                    @Override
-                    public void run() {
-                        mStackScrollerOverscrolling = false;
-                        setOverScrolling(false);
-                        updateQsState();
-                    }
-                }, false /* isClick */);
+        flingSettings(!mQsExpansionEnabled && open ? 0f : velocity, open && mQsExpansionEnabled, new Runnable() {
+            @Override
+            public void run() {
+                mStackScrollerOverscrolling = false;
+                setOverScrolling(false);
+                updateQsState();
+            }
+        }, false /* isClick */);
     }
 
     private void setOverScrolling(boolean overscrolling) {
         mStackScrollerOverscrolling = overscrolling;
-        if (mQs == null) return;
+        if (mQs == null)
+            return;
         mQs.setOverscrolling(overscrolling);
     }
 
@@ -1141,8 +1136,7 @@ public class NotificationPanelView extends PanelView implements
         }
     }
 
-    public void setBarState(int statusBarState, boolean keyguardFadingAway,
-            boolean goingToFullShade) {
+    public void setBarState(int statusBarState, boolean keyguardFadingAway, boolean goingToFullShade) {
         int oldState = mStatusBarState;
         boolean keyguardShowing = statusBarState == StatusBarState.KEYGUARD;
         setKeyguardStatusViewVisibility(statusBarState, keyguardFadingAway, goingToFullShade);
@@ -1157,11 +1151,10 @@ public class NotificationPanelView extends PanelView implements
         if (oldState == StatusBarState.KEYGUARD
                 && (goingToFullShade || statusBarState == StatusBarState.SHADE_LOCKED)) {
             animateKeyguardStatusBarOut();
-            long delay = mStatusBarState == StatusBarState.SHADE_LOCKED
-                    ? 0 : mStatusBar.calculateGoingToFullShadeDelay();
+            long delay = mStatusBarState == StatusBarState.SHADE_LOCKED ? 0
+                    : mStatusBar.calculateGoingToFullShadeDelay();
             mQs.animateHeaderSlidingIn(delay);
-        } else if (oldState == StatusBarState.SHADE_LOCKED
-                && statusBarState == StatusBarState.KEYGUARD) {
+        } else if (oldState == StatusBarState.SHADE_LOCKED && statusBarState == StatusBarState.KEYGUARD) {
             animateKeyguardStatusBarIn(StackStateAnimator.ANIMATION_DURATION_STANDARD);
             mQs.animateHeaderSlidingOut();
         } else {
@@ -1175,6 +1168,7 @@ public class NotificationPanelView extends PanelView implements
             }
         }
         if (keyguardShowing) {
+            mQsExpandImmediate = false;
             updateDozingVisibilities(false /* animate */);
         }
         resetVerticalPanelPosition();
@@ -1216,11 +1210,8 @@ public class NotificationPanelView extends PanelView implements
     private void animateKeyguardStatusBarOut() {
         ValueAnimator anim = ValueAnimator.ofFloat(mKeyguardStatusBar.getAlpha(), 0f);
         anim.addUpdateListener(mStatusBarAnimateAlphaListener);
-        anim.setStartDelay(mStatusBar.isKeyguardFadingAway()
-                ? mStatusBar.getKeyguardFadingAwayDelay()
-                : 0);
-        anim.setDuration(mStatusBar.isKeyguardFadingAway()
-                ? mStatusBar.getKeyguardFadingAwayDuration() / 2
+        anim.setStartDelay(mStatusBar.isKeyguardFadingAway() ? mStatusBar.getKeyguardFadingAwayDelay() : 0);
+        anim.setDuration(mStatusBar.isKeyguardFadingAway() ? mStatusBar.getKeyguardFadingAwayDuration() / 2
                 : StackStateAnimator.ANIMATION_DURATION_STANDARD);
         anim.setInterpolator(Interpolators.LINEAR_OUT_SLOW_IN);
         anim.addListener(new AnimatorListenerAdapter() {
@@ -1232,8 +1223,7 @@ public class NotificationPanelView extends PanelView implements
         anim.start();
     }
 
-    private final ValueAnimator.AnimatorUpdateListener mStatusBarAnimateAlphaListener =
-            new ValueAnimator.AnimatorUpdateListener() {
+    private final ValueAnimator.AnimatorUpdateListener mStatusBarAnimateAlphaListener = new ValueAnimator.AnimatorUpdateListener() {
         @Override
         public void onAnimationUpdate(ValueAnimator animation) {
             mKeyguardStatusBarAnimateAlpha = (float) animation.getAnimatedValue();
@@ -1258,19 +1248,14 @@ public class NotificationPanelView extends PanelView implements
         }
     };
 
-    private void setKeyguardBottomAreaVisibility(int statusBarState,
-            boolean goingToFullShade) {
+    private void setKeyguardBottomAreaVisibility(int statusBarState, boolean goingToFullShade) {
         mKeyguardBottomArea.animate().cancel();
         if (goingToFullShade) {
-            mKeyguardBottomArea.animate()
-                    .alpha(0f)
-                    .setStartDelay(mStatusBar.getKeyguardFadingAwayDelay())
+            mKeyguardBottomArea.animate().alpha(0f).setStartDelay(mStatusBar.getKeyguardFadingAwayDelay())
                     .setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2)
                     .setInterpolator(Interpolators.ALPHA_OUT)
-                    .withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable)
-                    .start();
-        } else if (statusBarState == StatusBarState.KEYGUARD
-                || statusBarState == StatusBarState.SHADE_LOCKED) {
+                    .withEndAction(mAnimateKeyguardBottomAreaInvisibleEndRunnable).start();
+        } else if (statusBarState == StatusBarState.KEYGUARD || statusBarState == StatusBarState.SHADE_LOCKED) {
             mKeyguardBottomArea.setVisibility(View.VISIBLE);
             mKeyguardBottomArea.setAlpha(1f);
         } else {
@@ -1286,40 +1271,25 @@ public class NotificationPanelView extends PanelView implements
         if ((!keyguardFadingAway && mStatusBarState == StatusBarState.KEYGUARD
                 && statusBarState != StatusBarState.KEYGUARD) || goingToFullShade) {
             mKeyguardStatusViewAnimating = true;
-            mKeyguardStatusView.animate()
-                    .alpha(0f)
-                    .setStartDelay(0)
-                    .setDuration(160)
-                    .setInterpolator(Interpolators.ALPHA_OUT)
-                    .withEndAction(mAnimateKeyguardStatusViewGoneEndRunnable);
+            mKeyguardStatusView.animate().alpha(0f).setStartDelay(0).setDuration(160)
+                    .setInterpolator(Interpolators.ALPHA_OUT).withEndAction(mAnimateKeyguardStatusViewGoneEndRunnable);
             if (keyguardFadingAway) {
-                mKeyguardStatusView.animate()
-                        .setStartDelay(mStatusBar.getKeyguardFadingAwayDelay())
-                        .setDuration(mStatusBar.getKeyguardFadingAwayDuration()/2)
-                        .start();
+                mKeyguardStatusView.animate().setStartDelay(mStatusBar.getKeyguardFadingAwayDelay())
+                        .setDuration(mStatusBar.getKeyguardFadingAwayDuration() / 2).start();
             }
-        } else if (mStatusBarState == StatusBarState.SHADE_LOCKED
-                && statusBarState == StatusBarState.KEYGUARD) {
+        } else if (mStatusBarState == StatusBarState.SHADE_LOCKED && statusBarState == StatusBarState.KEYGUARD) {
             mKeyguardStatusView.setVisibility(View.VISIBLE);
             mKeyguardStatusViewAnimating = true;
             mKeyguardStatusView.setAlpha(0f);
-            mKeyguardStatusView.animate()
-                    .alpha(1f)
-                    .setStartDelay(0)
-                    .setDuration(320)
+            mKeyguardStatusView.animate().alpha(1f).setStartDelay(0).setDuration(320)
                     .setInterpolator(Interpolators.ALPHA_IN)
                     .withEndAction(mAnimateKeyguardStatusViewVisibleEndRunnable);
         } else if (statusBarState == StatusBarState.KEYGUARD) {
             if (keyguardFadingAway) {
                 mKeyguardStatusViewAnimating = true;
-                mKeyguardStatusView.animate()
-                        .alpha(0)
-                        .translationYBy(-getHeight() * 0.05f)
-                        .setInterpolator(Interpolators.FAST_OUT_LINEAR_IN)
-                        .setDuration(125)
-                        .setStartDelay(0)
-                        .withEndAction(mAnimateKeyguardStatusViewInvisibleEndRunnable)
-                        .start();
+                mKeyguardStatusView.animate().alpha(0).translationYBy(-getHeight() * 0.05f)
+                        .setInterpolator(Interpolators.FAST_OUT_LINEAR_IN).setDuration(125).setStartDelay(0)
+                        .withEndAction(mAnimateKeyguardStatusViewInvisibleEndRunnable).start();
             } else {
                 mKeyguardStatusView.setVisibility(View.VISIBLE);
                 mKeyguardStatusView.setAlpha(1f);
@@ -1333,17 +1303,15 @@ public class NotificationPanelView extends PanelView implements
     private void updateQsState() {
         mNotificationStackScroller.setQsExpanded(mQsExpanded);
         mNotificationStackScroller.setScrollingEnabled(
-                mStatusBarState != StatusBarState.KEYGUARD && (!mQsExpanded
-                        || mQsExpansionFromOverscroll));
+                mStatusBarState != StatusBarState.KEYGUARD && (!mQsExpanded || mQsExpansionFromOverscroll));
         updateEmptyShadeView();
         mQsNavbarScrim.setVisibility(mStatusBarState == StatusBarState.SHADE && mQsExpanded
-                && !mStackScrollerOverscrolling && mQsScrimEnabled
-                        ? View.VISIBLE
-                        : View.INVISIBLE);
+                && !mStackScrollerOverscrolling && mQsScrimEnabled ? View.VISIBLE : View.INVISIBLE);
         if (mKeyguardUserSwitcher != null && mQsExpanded && !mStackScrollerOverscrolling) {
             mKeyguardUserSwitcher.hideIfNotSimple(true /* animate */);
         }
-        if (mQs == null) return;
+        if (mQs == null)
+            return;
         mQs.setExpanded(mQsExpanded);
     }
 
@@ -1359,12 +1327,10 @@ public class NotificationPanelView extends PanelView implements
         updateQsExpansion();
         requestScrollerTopPaddingUpdate(false /* animate */);
         updateHeaderKeyguardAlpha();
-        if (mStatusBarState == StatusBarState.SHADE_LOCKED
-                || mStatusBarState == StatusBarState.KEYGUARD) {
+        if (mStatusBarState == StatusBarState.SHADE_LOCKED || mStatusBarState == StatusBarState.KEYGUARD) {
             updateKeyguardBottomAreaAlpha();
         }
-        if (mStatusBarState == StatusBarState.SHADE && mQsExpanded
-                && !mStackScrollerOverscrolling && mQsScrimEnabled) {
+        if (mStatusBarState == StatusBarState.SHADE && mQsExpanded && !mStackScrollerOverscrolling && mQsScrimEnabled) {
             mQsNavbarScrim.setAlpha(getQsExpansionFraction());
         }
 
@@ -1373,8 +1339,8 @@ public class NotificationPanelView extends PanelView implements
         }
 
         if (mQsFullyExpanded && mFalsingManager.shouldEnforceBouncer()) {
-            mStatusBar.executeRunnableDismissingKeyguard(null, null /* cancelAction */,
-                    false /* dismissShade */, true /* afterKeyguardGone */, false /* deferred */);
+            mStatusBar.executeRunnableDismissingKeyguard(null, null /* cancelAction */, false /* dismissShade */,
+                    true /* afterKeyguardGone */, false /* deferred */);
         }
         if (DEBUG) {
             invalidate();
@@ -1382,7 +1348,8 @@ public class NotificationPanelView extends PanelView implements
     }
 
     protected void updateQsExpansion() {
-        if (mQs == null) return;
+        if (mQs == null)
+            return;
         float qsExpansionFraction = getQsExpansionFraction();
         mQs.setQsExpansion(qsExpansionFraction, getHeaderTranslation());
         mNotificationStackScroller.setQsExpansionFraction(qsExpansionFraction);
@@ -1392,7 +1359,8 @@ public class NotificationPanelView extends PanelView implements
         if (mQs != null && mQs.isCustomizing()) {
             return getContext().getString(R.string.accessibility_desc_quick_settings_edit);
         } else if (mQsExpansionHeight != 0.0f && mQsFullyExpanded) {
-            // Upon initialisation when we are not layouted yet we don't want to announce that we
+            // Upon initialisation when we are not layouted yet we don't want to announce
+            // that we
             // are fully expanded, hence the != 0.0f check.
             return getContext().getString(R.string.accessibility_desc_quick_settings);
         } else if (mStatusBarState == StatusBarState.KEYGUARD) {
@@ -1403,28 +1371,29 @@ public class NotificationPanelView extends PanelView implements
     }
 
     private float calculateQsTopPadding() {
-        if (mKeyguardShowing
-                && (mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted)) {
-
-            // Either QS pushes the notifications down when fully expanded, or QS is fully above the
-            // notifications (mostly on tablets). maxNotificationPadding denotes the normal top
-            // padding on Keyguard, maxQsPadding denotes the top padding from the quick settings
-            // panel. We need to take the maximum and linearly interpolate with the panel expansion
+        if (mKeyguardShowing && (mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted)) {
+
+            // Either QS pushes the notifications down when fully expanded, or QS is fully
+            // above the
+            // notifications (mostly on tablets). maxNotificationPadding denotes the normal
+            // top
+            // padding on Keyguard, maxQsPadding denotes the top padding from the quick
+            // settings
+            // panel. We need to take the maximum and linearly interpolate with the panel
+            // expansion
             // for a nice motion.
             int maxNotificationPadding = mClockPositionResult.stackScrollerPadding;
             int maxQsPadding = mQsMaxExpansionHeight + mQsNotificationTopPadding;
-            int max = mStatusBarState == StatusBarState.KEYGUARD
-                    ? Math.max(maxNotificationPadding, maxQsPadding)
+            int max = mStatusBarState == StatusBarState.KEYGUARD ? Math.max(maxNotificationPadding, maxQsPadding)
                     : maxQsPadding;
-            return (int) interpolate(getExpandedFraction(),
-                    mQsMinExpansionHeight, max);
+            return (int) interpolate(getExpandedFraction(), mQsMinExpansionHeight, max);
         } else if (mQsSizeChangeAnimator != null) {
             return (int) mQsSizeChangeAnimator.getAnimatedValue();
         } else if (mKeyguardShowing) {
-            // We can only do the smoother transition on Keyguard when we also are not collapsing
+            // We can only do the smoother transition on Keyguard when we also are not
+            // collapsing
             // from a scrolled quick settings.
-            return interpolate(getQsExpansionFraction(),
-                    mNotificationStackScroller.getIntrinsicPadding(),
+            return interpolate(getQsExpansionFraction(), mNotificationStackScroller.getIntrinsicPadding(),
                     mQsMaxExpansionHeight + mQsNotificationTopPadding);
         } else {
             return mQsExpansionHeight + mQsNotificationTopPadding;
@@ -1432,13 +1401,13 @@ public class NotificationPanelView extends PanelView implements
     }
 
     protected void requestScrollerTopPaddingUpdate(boolean animate) {
-        mNotificationStackScroller.updateTopPadding(calculateQsTopPadding(),
-                animate, mKeyguardShowing
-                        && (mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted));
+        mNotificationStackScroller.updateTopPadding(calculateQsTopPadding(), animate,
+                mKeyguardShowing && (mQsExpandImmediate || mIsExpanding && mQsExpandedWhenExpandingStarted));
     }
 
     private void trackMovement(MotionEvent event) {
-        if (mQsVelocityTracker != null) mQsVelocityTracker.addMovement(event);
+        if (mQsVelocityTracker != null)
+            mQsVelocityTracker.addMovement(event);
         mLastTouchX = event.getX();
         mLastTouchY = event.getY();
     }
@@ -1468,8 +1437,7 @@ public class NotificationPanelView extends PanelView implements
         flingSettings(vel, expand, null, false /* isClick */);
     }
 
-    protected void flingSettings(float vel, boolean expand, final Runnable onFinishRunnable,
-            boolean isClick) {
+    protected void flingSettings(float vel, boolean expand, final Runnable onFinishRunnable, boolean isClick) {
         float target = expand ? mQsMaxExpansionHeight : mQsMinExpansionHeight;
         if (target == mQsExpansionHeight) {
             if (onFinishRunnable != null) {
@@ -1478,7 +1446,8 @@ public class NotificationPanelView extends PanelView implements
             return;
         }
 
-        // If we move in the opposite direction, reset velocity and use a different duration.
+        // If we move in the opposite direction, reset velocity and use a different
+        // duration.
         boolean oppositeDirection = false;
         if (vel > 0 && !expand || vel < 0 && expand) {
             vel = 0;
@@ -1523,8 +1492,7 @@ public class NotificationPanelView extends PanelView implements
             return false;
         }
         View header = mKeyguardShowing ? mKeyguardStatusBar : mQs.getHeader();
-        final boolean onHeader = x >= mQsFrame.getX()
-                && x <= mQsFrame.getX() + mQsFrame.getWidth()
+        final boolean onHeader = x >= mQsFrame.getX() && x <= mQsFrame.getX() + mQsFrame.getWidth()
                 && y >= header.getTop() && y <= header.getBottom();
         if (mQsExpanded) {
             return onHeader || (yDiff < 0 && isInQsArea(x, y));
@@ -1577,29 +1545,29 @@ public class NotificationPanelView extends PanelView implements
             // This is a circular dependency and should be avoided, otherwise we'll have
             // a stack overflow.
             if (mStackScrollerMeasuringPass > 2) {
-                if (DEBUG) Log.d(TAG, "Unstable notification panel height. Aborting.");
+                if (DEBUG)
+                    Log.d(TAG, "Unstable notification panel height. Aborting.");
             } else {
                 positionClockAndNotifications();
             }
         }
-        if (mQsExpandImmediate || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null
-                && !mQsExpansionFromOverscroll) {
+        if (mQsExpandImmediate
+                || mQsExpanded && !mQsTracking && mQsExpansionAnimator == null && !mQsExpansionFromOverscroll) {
             float t;
             if (mKeyguardShowing) {
 
                 // On Keyguard, interpolate the QS expansion linearly to the panel expansion
                 t = expandedHeight / (getMaxPanelHeight());
             } else {
-                // In Shade, interpolate linearly such that QS is closed whenever panel height is
+                // In Shade, interpolate linearly such that QS is closed whenever panel height
+                // is
                 // minimum QS expansion + minStackHeight
                 float panelHeightQsCollapsed = mNotificationStackScroller.getIntrinsicPadding()
                         + mNotificationStackScroller.getLayoutMinHeight();
                 float panelHeightQsExpanded = calculatePanelHeightQsExpanded();
-                t = (expandedHeight - panelHeightQsCollapsed)
-                        / (panelHeightQsExpanded - panelHeightQsCollapsed);
+                t = (expandedHeight - panelHeightQsCollapsed) / (panelHeightQsExpanded - panelHeightQsCollapsed);
             }
-            setQsExpansion(mQsMinExpansionHeight
-                    + t * (mQsMaxExpansionHeight - mQsMinExpansionHeight));
+            setQsExpansion(mQsMinExpansionHeight + t * (mQsMaxExpansionHeight - mQsMinExpansionHeight));
         }
         updateExpandedHeight(expandedHeight);
         updateHeader();
@@ -1628,8 +1596,7 @@ public class NotificationPanelView extends PanelView implements
 
         if (mStatusBarState == StatusBarState.KEYGUARD) {
             int minKeyguardPanelBottom = mClockPositionAlgorithm.getExpandedClockPosition()
-                    + mKeyguardStatusView.getHeight()
-                    + mNotificationStackScroller.getIntrinsicContentHeight();
+                    + mKeyguardStatusView.getHeight() + mNotificationStackScroller.getIntrinsicContentHeight();
             return Math.max(maxHeight, minKeyguardPanelBottom);
         } else {
             return maxHeight;
@@ -1638,14 +1605,14 @@ public class NotificationPanelView extends PanelView implements
 
     private int calculatePanelHeightQsExpanded() {
         float notificationHeight = mNotificationStackScroller.getHeight()
-                - mNotificationStackScroller.getEmptyBottomMargin()
-                - mNotificationStackScroller.getTopPadding();
+                - mNotificationStackScroller.getEmptyBottomMargin() - mNotificationStackScroller.getTopPadding();
 
-        // When only empty shade view is visible in QS collapsed state, simulate that we would have
-        // it in expanded QS state as well so we don't run into troubles when fading the view in/out
+        // When only empty shade view is visible in QS collapsed state, simulate that we
+        // would have
+        // it in expanded QS state as well so we don't run into troubles when fading the
+        // view in/out
         // and expanding/collapsing the whole panel from/to quick settings.
-        if (mNotificationStackScroller.getNotGoneChildCount() == 0
-                && mShowEmptyShadeView) {
+        if (mNotificationStackScroller.getNotGoneChildCount() == 0 && mShowEmptyShadeView) {
             notificationHeight = mNotificationStackScroller.getEmptyShadeViewHeight();
         }
         int maxQsHeight = mQsMaxExpansionHeight;
@@ -1654,17 +1621,16 @@ public class NotificationPanelView extends PanelView implements
             maxQsHeight += mQsNotificationTopPadding;
         }
 
-        // If an animation is changing the size of the QS panel, take the animated value.
+        // If an animation is changing the size of the QS panel, take the animated
+        // value.
         if (mQsSizeChangeAnimator != null) {
             maxQsHeight = (int) mQsSizeChangeAnimator.getAnimatedValue();
         }
-        float totalHeight = Math.max(
-                maxQsHeight, mStatusBarState == StatusBarState.KEYGUARD
-                        ? mClockPositionResult.stackScrollerPadding : 0)
+        float totalHeight = Math.max(maxQsHeight,
+                mStatusBarState == StatusBarState.KEYGUARD ? mClockPositionResult.stackScrollerPadding : 0)
                 + notificationHeight + mNotificationStackScroller.getTopPaddingOverflow();
         if (totalHeight > mNotificationStackScroller.getHeight()) {
-            float fullyCollapsedHeight = maxQsHeight
-                    + mNotificationStackScroller.getLayoutMinHeight();
+            float fullyCollapsedHeight = maxQsHeight + mNotificationStackScroller.getLayoutMinHeight();
             totalHeight = Math.max(fullyCollapsedHeight, mNotificationStackScroller.getHeight());
         }
         return (int) totalHeight;
@@ -1672,8 +1638,7 @@ public class NotificationPanelView extends PanelView implements
 
     private void updateNotificationTranslucency() {
         float alpha = 1f;
-        if (mClosingWithAlphaFadeOut && !mExpandingFromHeadsUp &&
-                !mHeadsUpManager.hasPinnedHeadsUp()) {
+        if (mClosingWithAlphaFadeOut && !mExpandingFromHeadsUp && !mHeadsUpManager.hasPinnedHeadsUp()) {
             alpha = getFadeoutAlpha();
         }
         mNotificationStackScroller.setAlpha(alpha);
@@ -1704,13 +1669,11 @@ public class NotificationPanelView extends PanelView implements
             KeyguardAffordanceView lockIcon = mKeyguardBottomArea.getLockIcon();
             if (active && !mUnlockIconActive && mTracking) {
                 lockIcon.setImageAlpha(1.0f, true, 150, Interpolators.FAST_OUT_LINEAR_IN, null);
-                lockIcon.setImageScale(LOCK_ICON_ACTIVE_SCALE, true, 150,
-                        Interpolators.FAST_OUT_LINEAR_IN);
+                lockIcon.setImageScale(LOCK_ICON_ACTIVE_SCALE, true, 150, Interpolators.FAST_OUT_LINEAR_IN);
             } else if (!active && mUnlockIconActive && mTracking) {
-                lockIcon.setImageAlpha(lockIcon.getRestingAlpha(), true /* animate */,
-                        150, Interpolators.FAST_OUT_LINEAR_IN, null);
-                lockIcon.setImageScale(1.0f, true, 150,
-                        Interpolators.FAST_OUT_LINEAR_IN);
+                lockIcon.setImageAlpha(lockIcon.getRestingAlpha(), true /* animate */, 150,
+                        Interpolators.FAST_OUT_LINEAR_IN, null);
+                lockIcon.setImageScale(1.0f, true, 150, Interpolators.FAST_OUT_LINEAR_IN);
             }
             mUnlockIconActive = active;
         }
@@ -1731,27 +1694,27 @@ public class NotificationPanelView extends PanelView implements
             return 0;
         }
         float translation = MathUtils.lerp(-mQsMinExpansionHeight, 0,
-                Math.min(1.0f, mNotificationStackScroller.getAppearFraction(mExpandedHeight)))
-                + mExpandOffset;
+                Math.min(1.0f, mNotificationStackScroller.getAppearFraction(mExpandedHeight))) + mExpandOffset;
         return Math.min(0, translation);
     }
 
     /**
-     * @return the alpha to be used to fade out the contents on Keyguard (status bar, bottom area)
-     *         during swiping up
+     * @return the alpha to be used to fade out the contents on Keyguard (status
+     *         bar, bottom area) during swiping up
      */
     private float getKeyguardContentsAlpha() {
         float alpha;
         if (mStatusBar.getBarState() == StatusBarState.KEYGUARD) {
 
-            // When on Keyguard, we hide the header as soon as the top card of the notification
-            // stack scroller is close enough (collision distance) to the bottom of the header.
-            alpha = getNotificationsTopY()
-                    /
-                    (mKeyguardStatusBar.getHeight() + mNotificationsHeaderCollideDistance);
+            // When on Keyguard, we hide the header as soon as the top card of the
+            // notification
+            // stack scroller is close enough (collision distance) to the bottom of the
+            // header.
+            alpha = getNotificationsTopY() / (mKeyguardStatusBar.getHeight() + mNotificationsHeaderCollideDistance);
         } else {
 
-            // In SHADE_LOCKED, the top card is already really close to the header. Hide it as
+            // In SHADE_LOCKED, the top card is already really close to the header. Hide it
+            // as
             // soon as we start translating the stack.
             alpha = getNotificationsTopY() / mKeyguardStatusBar.getHeight();
         }
@@ -1765,27 +1728,27 @@ public class NotificationPanelView extends PanelView implements
             return;
         }
         float alphaQsExpansion = 1 - Math.min(1, getQsExpansionFraction() * 2);
-        mKeyguardStatusBar.setAlpha(Math.min(getKeyguardContentsAlpha(), alphaQsExpansion)
-                * mKeyguardStatusBarAnimateAlpha);
-        mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f
-                && !mDozing ? VISIBLE : INVISIBLE);
+        mKeyguardStatusBar
+                .setAlpha(Math.min(getKeyguardContentsAlpha(), alphaQsExpansion) * mKeyguardStatusBarAnimateAlpha);
+        mKeyguardStatusBar.setVisibility(mKeyguardStatusBar.getAlpha() != 0f && !mDozing ? VISIBLE : INVISIBLE);
     }
 
     private void updateKeyguardBottomAreaAlpha() {
         // There are two possible panel expansion behaviors:
         // • User dragging up to unlock: we want to fade out as quick as possible
-        //   (ALPHA_EXPANSION_THRESHOLD) to avoid seeing the bouncer over the bottom area.
-        // • User tapping on lock screen: bouncer won't be visible but panel expansion will
-        //   change due to "unlock hint animation." In this case, fading out the bottom area
-        //   would also hide the message that says "swipe to unlock," we don't want to do that.
-        float expansionAlpha = MathUtils.map(isUnlockHintRunning()
-                        ? 0 : KeyguardBouncer.ALPHA_EXPANSION_THRESHOLD, 1f,
+        // (ALPHA_EXPANSION_THRESHOLD) to avoid seeing the bouncer over the bottom area.
+        // • User tapping on lock screen: bouncer won't be visible but panel expansion
+        // will
+        // change due to "unlock hint animation." In this case, fading out the bottom
+        // area
+        // would also hide the message that says "swipe to unlock," we don't want to do
+        // that.
+        float expansionAlpha = MathUtils.map(isUnlockHintRunning() ? 0 : KeyguardBouncer.ALPHA_EXPANSION_THRESHOLD, 1f,
                 0f, 1f, getExpandedFraction());
         float alpha = Math.min(expansionAlpha, 1 - getQsExpansionFraction());
         mKeyguardBottomArea.setAlpha(alpha);
-        mKeyguardBottomArea.setImportantForAccessibility(alpha == 0f
-                ? IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS
-                : IMPORTANT_FOR_ACCESSIBILITY_AUTO);
+        mKeyguardBottomArea.setImportantForAccessibility(
+                alpha == 0f ? IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS : IMPORTANT_FOR_ACCESSIBILITY_AUTO);
         View ambientIndicationContainer = mStatusBar.getAmbientIndicationContainer();
         if (ambientIndicationContainer != null) {
             ambientIndicationContainer.setAlpha(alpha);
@@ -1808,9 +1771,11 @@ public class NotificationPanelView extends PanelView implements
         if (mQsExpanded) {
             onQsExpansionStarted();
         }
-        // Since there are QS tiles in the header now, we need to make sure we start listening
+        // Since there are QS tiles in the header now, we need to make sure we start
+        // listening
         // immediately so they can be up to date.
-        if (mQs == null) return;
+        if (mQs == null)
+            return;
         mQs.setHeaderListening(true);
     }
 
@@ -1828,8 +1793,10 @@ public class NotificationPanelView extends PanelView implements
                 }
             });
 
-            // Workaround b/22639032: Make sure we invalidate something because else RenderThread
-            // thinks we are actually drawing a frame put in reality we don't, so RT doesn't go
+            // Workaround b/22639032: Make sure we invalidate something because else
+            // RenderThread
+            // thinks we are actually drawing a frame put in reality we don't, so RT doesn't
+            // go
             // ahead with rendering and we jank.
             postOnAnimation(new Runnable() {
                 @Override
@@ -1851,15 +1818,15 @@ public class NotificationPanelView extends PanelView implements
 
     private void notifyListenersTrackingHeadsUp(ExpandableNotificationRow pickedChild) {
         for (int i = 0; i < mTrackingHeadsUpListeners.size(); i++) {
-            Consumer<ExpandableNotificationRow> listener
-                    = mTrackingHeadsUpListeners.get(i);
+            Consumer<ExpandableNotificationRow> listener = mTrackingHeadsUpListeners.get(i);
             listener.accept(pickedChild);
         }
     }
 
     private void setListening(boolean listening) {
         mKeyguardStatusBar.setListening(listening);
-        if (mQs == null) return;
+        if (mQs == null)
+            return;
         mQs.setListening(listening);
     }
 
@@ -1877,11 +1844,9 @@ public class NotificationPanelView extends PanelView implements
         if (mStatusBar.getBarState() != StatusBarState.KEYGUARD) {
             mNotificationStackScroller.setOnHeightChangedListener(null);
             if (isPixels) {
-                mNotificationStackScroller.setOverScrolledPixels(
-                        overExpansion, true /* onTop */, false /* animate */);
+                mNotificationStackScroller.setOverScrolledPixels(overExpansion, true /* onTop */, false /* animate */);
             } else {
-                mNotificationStackScroller.setOverScrollAmount(
-                        overExpansion, true /* onTop */, false /* animate */);
+                mNotificationStackScroller.setOverScrollAmount(overExpansion, true /* onTop */, false /* animate */);
             }
             mNotificationStackScroller.setOnHeightChangedListener(this);
         }
@@ -1907,8 +1872,7 @@ public class NotificationPanelView extends PanelView implements
         mFalsingManager.onTrackingStopped();
         super.onTrackingStopped(expand);
         if (expand) {
-            mNotificationStackScroller.setOverScrolledPixels(
-                    0.0f, true /* onTop */, true /* animate */);
+            mNotificationStackScroller.setOverScrolledPixels(0.0f, true /* onTop */, true /* animate */);
         }
         mNotificationStackScroller.onPanelTrackingStopped();
         if (expand && (mStatusBar.getBarState() == StatusBarState.KEYGUARD
@@ -1940,8 +1904,7 @@ public class NotificationPanelView extends PanelView implements
         ExpandableNotificationRow firstRow = firstChildNotGone instanceof ExpandableNotificationRow
                 ? (ExpandableNotificationRow) firstChildNotGone
                 : null;
-        if (firstRow != null
-                && (view == firstRow || (firstRow.getNotificationParent() == firstRow))) {
+        if (firstRow != null && (view == firstRow || (firstRow.getNotificationParent() == firstRow))) {
             requestScrollerTopPaddingUpdate(false /* animate */);
         }
         requestPanelHeightUpdate();
@@ -1961,8 +1924,7 @@ public class NotificationPanelView extends PanelView implements
         if (mAccessibilityManager.isEnabled()) {
             setAccessibilityPaneTitle(determineAccessibilityPaneTitle());
         }
-        mNotificationStackScroller.setMaxTopPadding(
-                mQsMaxExpansionHeight + mQsNotificationTopPadding);
+        mNotificationStackScroller.setMaxTopPadding(mQsMaxExpansionHeight + mQsNotificationTopPadding);
     }
 
     @Override
@@ -2023,15 +1985,12 @@ public class NotificationPanelView extends PanelView implements
                     public void run() {
                         mKeyguardBottomArea.launchLeftAffordance();
                     }
-                }, null, true /* dismissShade */, false /* afterKeyguardGone */,
-                        true /* deferred */);
-            }
-            else {
+                }, null, true /* dismissShade */, false /* afterKeyguardGone */, true /* deferred */);
+            } else {
                 mKeyguardBottomArea.launchLeftAffordance();
             }
         } else {
-            if (KeyguardBottomAreaView.CAMERA_LAUNCH_SOURCE_AFFORDANCE.equals(
-                    mLastCameraLaunchSource)) {
+            if (KeyguardBottomAreaView.CAMERA_LAUNCH_SOURCE_AFFORDANCE.equals(mLastCameraLaunchSource)) {
                 mLockscreenGestureLogger.write(MetricsEvent.ACTION_LS_CAMERA, lengthDp, velocityDp);
             }
             mFalsingManager.onCameraOn();
@@ -2041,10 +2000,8 @@ public class NotificationPanelView extends PanelView implements
                     public void run() {
                         mKeyguardBottomArea.launchCamera(mLastCameraLaunchSource);
                     }
-                }, null, true /* dismissShade */, false /* afterKeyguardGone */,
-                    true /* deferred */);
-            }
-            else {
+                }, null, true /* dismissShade */, false /* afterKeyguardGone */, true /* deferred */);
+            } else {
                 mKeyguardBottomArea.launchCamera(mLastCameraLaunchSource);
             }
         }
@@ -2078,13 +2035,12 @@ public class NotificationPanelView extends PanelView implements
      * Starts the highlight (making it fully opaque) animation on an icon.
      */
     private void startHighlightIconAnimation(final KeyguardAffordanceView icon) {
-        icon.setImageAlpha(1.0f, true, KeyguardAffordanceHelper.HINT_PHASE1_DURATION,
-                Interpolators.FAST_OUT_SLOW_IN, new Runnable() {
+        icon.setImageAlpha(1.0f, true, KeyguardAffordanceHelper.HINT_PHASE1_DURATION, Interpolators.FAST_OUT_SLOW_IN,
+                new Runnable() {
                     @Override
                     public void run() {
-                        icon.setImageAlpha(icon.getRestingAlpha(),
-                                true /* animate */, KeyguardAffordanceHelper.HINT_PHASE1_DURATION,
-                                Interpolators.FAST_OUT_SLOW_IN, null);
+                        icon.setImageAlpha(icon.getRestingAlpha(), true /* animate */,
+                                KeyguardAffordanceHelper.HINT_PHASE1_DURATION, Interpolators.FAST_OUT_SLOW_IN, null);
                     }
                 });
     }
@@ -2097,8 +2053,7 @@ public class NotificationPanelView extends PanelView implements
     @Override
     public void onSwipingStarted(boolean rightIcon) {
         mFalsingManager.onAffordanceSwipingStarted(rightIcon);
-        boolean camera = getLayoutDirection() == LAYOUT_DIRECTION_RTL ? !rightIcon
-                : rightIcon;
+        boolean camera = getLayoutDirection() == LAYOUT_DIRECTION_RTL ? !rightIcon : rightIcon;
         if (camera) {
             mKeyguardBottomArea.bindCameraPrewarmService();
         }
@@ -2152,8 +2107,7 @@ public class NotificationPanelView extends PanelView implements
 
     @Override
     public KeyguardAffordanceView getLeftIcon() {
-        return getLayoutDirection() == LAYOUT_DIRECTION_RTL
-                ? mKeyguardBottomArea.getRightView()
+        return getLayoutDirection() == LAYOUT_DIRECTION_RTL ? mKeyguardBottomArea.getRightView()
                 : mKeyguardBottomArea.getLeftView();
     }
 
@@ -2164,22 +2118,19 @@ public class NotificationPanelView extends PanelView implements
 
     @Override
     public KeyguardAffordanceView getRightIcon() {
-        return getLayoutDirection() == LAYOUT_DIRECTION_RTL
-                ? mKeyguardBottomArea.getLeftView()
+        return getLayoutDirection() == LAYOUT_DIRECTION_RTL ? mKeyguardBottomArea.getLeftView()
                 : mKeyguardBottomArea.getRightView();
     }
 
     @Override
     public View getLeftPreview() {
-        return getLayoutDirection() == LAYOUT_DIRECTION_RTL
-                ? mKeyguardBottomArea.getRightPreview()
+        return getLayoutDirection() == LAYOUT_DIRECTION_RTL ? mKeyguardBottomArea.getRightPreview()
                 : mKeyguardBottomArea.getLeftPreview();
     }
 
     @Override
     public View getRightPreview() {
-        return getLayoutDirection() == LAYOUT_DIRECTION_RTL
-                ? mKeyguardBottomArea.getLeftPreview()
+        return getLayoutDirection() == LAYOUT_DIRECTION_RTL ? mKeyguardBottomArea.getLeftPreview()
                 : mKeyguardBottomArea.getRightPreview();
     }
 
@@ -2204,14 +2155,13 @@ public class NotificationPanelView extends PanelView implements
 
     @Override
     protected boolean shouldUseDismissingAnimation() {
-        return mStatusBarState != StatusBarState.SHADE
-                && (!mStatusBar.isKeyguardCurrentlySecure() || !isTracking());
+        return mStatusBarState != StatusBarState.SHADE && (!mStatusBar.isKeyguardCurrentlySecure() || !isTracking());
     }
 
     @Override
     protected boolean fullyExpandedClearAllVisible() {
-        return mNotificationStackScroller.isFooterViewNotGone()
-                && mNotificationStackScroller.isScrolledToBottom() && !mQsExpandImmediate;
+        return mNotificationStackScroller.isFooterViewNotGone() && mNotificationStackScroller.isScrolledToBottom()
+                && !mQsExpandImmediate;
     }
 
     @Override
@@ -2326,27 +2276,27 @@ public class NotificationPanelView extends PanelView implements
     @Override
     protected boolean onMiddleClicked() {
         switch (mStatusBar.getBarState()) {
-            case StatusBarState.KEYGUARD:
-                if (!mDozingOnDown) {
-                    mLockscreenGestureLogger.write(
-                            MetricsEvent.ACTION_LS_HINT,
-                            0 /* lengthDp - N/A */, 0 /* velocityDp - N/A */);
-                    startUnlockHintAnimation();
-                }
-                return true;
-            case StatusBarState.SHADE_LOCKED:
-                if (!mQsExpanded) {
-                    mStatusBar.goToKeyguard();
-                }
-                return true;
-            case StatusBarState.SHADE:
+        case StatusBarState.KEYGUARD:
+            if (!mDozingOnDown) {
+                mLockscreenGestureLogger.write(MetricsEvent.ACTION_LS_HINT, 0 /* lengthDp - N/A */,
+                        0 /* velocityDp - N/A */);
+                startUnlockHintAnimation();
+            }
+            return true;
+        case StatusBarState.SHADE_LOCKED:
+            if (!mQsExpanded) {
+                mStatusBar.goToKeyguard();
+            }
+            return true;
+        case StatusBarState.SHADE:
 
-                // This gets called in the middle of the touch handling, where the state is still
-                // that we are tracking the panel. Collapse the panel after this is done.
-                post(mPostCollapseRunnable);
-                return false;
-            default:
-                return true;
+            // This gets called in the middle of the touch handling, where the state is
+            // still
+            // that we are tracking the panel. Collapse the panel after this is done.
+            post(mPostCollapseRunnable);
+            return false;
+        default:
+            return true;
         }
     }
 
@@ -2395,20 +2345,16 @@ public class NotificationPanelView extends PanelView implements
             p.setColor(Color.BLUE);
             canvas.drawLine(0, getExpandedHeight(), getWidth(), getExpandedHeight(), p);
             p.setColor(Color.GREEN);
-            canvas.drawLine(0, calculatePanelHeightQsExpanded(), getWidth(),
-                    calculatePanelHeightQsExpanded(), p);
+            canvas.drawLine(0, calculatePanelHeightQsExpanded(), getWidth(), calculatePanelHeightQsExpanded(), p);
             p.setColor(Color.YELLOW);
-            canvas.drawLine(0, calculatePanelHeightShade(), getWidth(),
-                    calculatePanelHeightShade(), p);
+            canvas.drawLine(0, calculatePanelHeightShade(), getWidth(), calculatePanelHeightShade(), p);
             p.setColor(Color.MAGENTA);
-            canvas.drawLine(0, calculateQsTopPadding(), getWidth(),
-                    calculateQsTopPadding(), p);
+            canvas.drawLine(0, calculateQsTopPadding(), getWidth(), calculateQsTopPadding(), p);
             p.setColor(Color.CYAN);
             canvas.drawLine(0, mClockPositionResult.stackScrollerPadding, getWidth(),
                     mNotificationStackScroller.getTopPadding(), p);
             p.setColor(Color.GRAY);
-            canvas.drawLine(0, mClockPositionResult.clockY, getWidth(),
-                    mClockPositionResult.clockY, p);
+            canvas.drawLine(0, mClockPositionResult.clockY, getWidth(), mClockPositionResult.clockY, p);
         }
     }
 
@@ -2420,8 +2366,7 @@ public class NotificationPanelView extends PanelView implements
             updateNotificationTranslucency();
         } else {
             setHeadsUpAnimatingAway(true);
-            mNotificationStackScroller.runAfterAnimationFinished(
-                    mHeadsUpExistenceChangedRunnable);
+            mNotificationStackScroller.runAfterAnimationFinished(mHeadsUpExistenceChangedRunnable);
         }
     }
 
@@ -2438,8 +2383,10 @@ public class NotificationPanelView extends PanelView implements
     @Override
     public void onHeadsUpUnPinned(ExpandableNotificationRow headsUp) {
 
-        // When we're unpinning the notification via active edge they remain heads-upped,
-        // we need to make sure that an animation happens in this case, otherwise the notification
+        // When we're unpinning the notification via active edge they remain
+        // heads-upped,
+        // we need to make sure that an animation happens in this case, otherwise the
+        // notification
         // will stick to the top without any interaction.
         if (isFullyCollapsed() && headsUp.isHeadsUp()) {
             mNotificationStackScroller.generateHeadsUpAnimation(headsUp, false);
@@ -2455,8 +2402,7 @@ public class NotificationPanelView extends PanelView implements
     @Override
     public void setHeadsUpManager(HeadsUpManagerPhone headsUpManager) {
         super.setHeadsUpManager(headsUpManager);
-        mHeadsUpTouchHelper = new HeadsUpTouchHelper(headsUpManager, mNotificationStackScroller,
-                this);
+        mHeadsUpTouchHelper = new HeadsUpTouchHelper(headsUpManager, mNotificationStackScroller, this);
     }
 
     public void setTrackedHeadsUp(ExpandableNotificationRow pickedChild) {
@@ -2480,8 +2426,8 @@ public class NotificationPanelView extends PanelView implements
     }
 
     /**
-     * Updates the vertical position of the panel so it is positioned closer to the touch
-     * responsible for opening the panel.
+     * Updates the vertical position of the panel so it is positioned closer to the
+     * touch responsible for opening the panel.
      *
      * @param x the x-coordinate the touch event
      */
@@ -2491,15 +2437,14 @@ public class NotificationPanelView extends PanelView implements
             return;
         }
         float leftMost = mPositionMinSideMargin + mNotificationStackScroller.getWidth() / 2;
-        float rightMost = getWidth() - mPositionMinSideMargin
-                - mNotificationStackScroller.getWidth() / 2;
+        float rightMost = getWidth() - mPositionMinSideMargin - mNotificationStackScroller.getWidth() / 2;
         if (Math.abs(x - getWidth() / 2) < mNotificationStackScroller.getWidth() / 4) {
             x = getWidth() / 2;
         }
         x = Math.min(rightMost, Math.max(leftMost, x));
-        setVerticalPanelTranslation(x -
-                (mNotificationStackScroller.getLeft() + mNotificationStackScroller.getWidth() / 2));
-     }
+        setVerticalPanelTranslation(
+                x - (mNotificationStackScroller.getLeft() + mNotificationStackScroller.getWidth() / 2));
+    }
 
     private void resetVerticalPanelPosition() {
         setVerticalPanelTranslation(0f);
@@ -2524,8 +2469,8 @@ public class NotificationPanelView extends PanelView implements
     }
 
     /**
-     * @return whether the notifications are displayed full width and don't have any margins on
-     *         the side.
+     * @return whether the notifications are displayed full width and don't have any
+     *         margins on the side.
      */
     public boolean isFullWidth() {
         return mIsFullWidth;
@@ -2577,8 +2522,10 @@ public class NotificationPanelView extends PanelView implements
             mLastCameraLaunchSource = KeyguardBottomAreaView.CAMERA_LAUNCH_SOURCE_AFFORDANCE;
         }
 
-        // If we are launching it when we are occluded already we don't want it to animate,
-        // nor setting these flags, since the occluded state doesn't change anymore, hence it's
+        // If we are launching it when we are occluded already we don't want it to
+        // animate,
+        // nor setting these flags, since the occluded state doesn't change anymore,
+        // hence it's
         // never reset.
         if (!isFullyCollapsed()) {
             mLaunchingAffordance = true;
@@ -2602,8 +2549,9 @@ public class NotificationPanelView extends PanelView implements
     }
 
     /**
-     * Must be called before starting a ViewPropertyAnimator alpha animation because those
-     * do NOT call setAlpha and therefore don't properly update the fullyVisibleState.
+     * Must be called before starting a ViewPropertyAnimator alpha animation because
+     * those do NOT call setAlpha and therefore don't properly update the
+     * fullyVisibleState.
      */
     public void notifyStartFading() {
         updateFullyVisibleState(true /* forceNotFullyVisible */);
@@ -2616,14 +2564,13 @@ public class NotificationPanelView extends PanelView implements
     }
 
     private void updateFullyVisibleState(boolean forceNotFullyVisible) {
-        mNotificationStackScroller.setParentNotFullyVisible(forceNotFullyVisible
-                || getAlpha() != 1.0f
-                || getVisibility() != VISIBLE);
+        mNotificationStackScroller
+                .setParentNotFullyVisible(forceNotFullyVisible || getAlpha() != 1.0f || getVisibility() != VISIBLE);
     }
 
     /**
-     * Set whether we are currently launching an affordance. This is currently only set when
-     * launched via a camera gesture.
+     * Set whether we are currently launching an affordance. This is currently only
+     * set when launched via a camera gesture.
      */
     private void setLaunchingAffordance(boolean launchingAffordance) {
         getLeftIcon().setLaunchingAffordance(launchingAffordance);
@@ -2632,7 +2579,8 @@ public class NotificationPanelView extends PanelView implements
     }
 
     /**
-     * Return true when a bottom affordance is launching an occluded activity with a splash screen.
+     * Return true when a bottom affordance is launching an occluded activity with a
+     * splash screen.
      */
     public boolean isLaunchingAffordanceWithPreview() {
         return mLaunchingAffordance && mAffordanceHasPreview;
@@ -2649,15 +2597,15 @@ public class NotificationPanelView extends PanelView implements
         }
 
         ResolveInfo resolveInfo = mKeyguardBottomArea.resolveCameraIntent();
-        String packageToLaunch = (resolveInfo == null || resolveInfo.activityInfo == null)
-                ? null : resolveInfo.activityInfo.packageName;
-        return packageToLaunch != null &&
-               (keyguardIsShowing || !isForegroundApp(packageToLaunch)) &&
-               !mAffordanceHelper.isSwipingInProgress();
+        String packageToLaunch = (resolveInfo == null || resolveInfo.activityInfo == null) ? null
+                : resolveInfo.activityInfo.packageName;
+        return packageToLaunch != null && (keyguardIsShowing || !isForegroundApp(packageToLaunch))
+                && !mAffordanceHelper.isSwipingInProgress();
     }
 
     /**
-     * Return true if the applications with the package name is running in foreground.
+     * Return true if the applications with the package name is running in
+     * foreground.
      *
      * @param pkgName application package name.
      */
@@ -2675,13 +2623,50 @@ public class NotificationPanelView extends PanelView implements
         if (mLaunchingNotification) {
             return mHideIconsDuringNotificationLaunch;
         }
-        if (mHeadsUpAppearanceController != null
-                && mHeadsUpAppearanceController.shouldBeVisible()) {
+        if (mHeadsUpAppearanceController != null && mHeadsUpAppearanceController.shouldBeVisible()) {
             return false;
         }
         return !isFullWidth() || !mShowIconsWhenExpanded;
     }
 
+    class SettingsObserver extends ContentObserver {
+        SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        void observe() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(Settings.Secure.getUriFor(Settings.System.DOUBLE_TAP_SLEEP_GESTURE), false,
+                    this, UserHandle.USER_ALL);
+            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DOUBLE_TAP_SLEEP_LOCKSCREEN),
+                    false, this, UserHandle.USER_ALL);
+            update();
+        }
+
+        void unobserve() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.unregisterContentObserver(this);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            update();
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            update();
+        }
+
+        public void update() {
+            ContentResolver resolver = mContext.getContentResolver();
+            mDoubleTapToSleepEnabled = Settings.System.getIntForUser(resolver, Settings.System.DOUBLE_TAP_SLEEP_GESTURE,
+                    0, UserHandle.USER_CURRENT) == 1;
+            mDoubleTapToSleepAnywhere = Settings.System.getIntForUser(resolver,
+                    Settings.System.DOUBLE_TAP_SLEEP_LOCKSCREEN, 0, UserHandle.USER_CURRENT) == 1;
+        }
+    }
+
     private final FragmentListener mFragmentListener = new FragmentListener() {
         @Override
         public void onFragmentViewCreated(String tag, Fragment fragment) {
@@ -2693,8 +2678,8 @@ public class NotificationPanelView extends PanelView implements
             mQs.setOverscrolling(mStackScrollerOverscrolling);
 
             // recompute internal state when qspanel height changes
-            mQs.getView().addOnLayoutChangeListener(
-                    (v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom) -> {
+            mQs.getView()
+                    .addOnLayoutChangeListener((v, left, top, right, bottom, oldLeft, oldTop, oldRight, oldBottom) -> {
                         final int height = bottom - top;
                         final int oldHeight = oldBottom - oldTop;
                         if (height != oldHeight) {
@@ -2708,8 +2693,10 @@ public class NotificationPanelView extends PanelView implements
         @Override
         public void onFragmentViewDestroyed(String tag, Fragment fragment) {
             // Manual handling of fragment lifecycle is only required because this bridges
-            // non-fragment and fragment code. Once we are using a fragment for the notification
-            // panel, mQs will not need to be null cause it will be tied to the same lifecycle.
+            // non-fragment and fragment code. Once we are using a fragment for the
+            // notification
+            // panel, mQs will not need to be null cause it will be tied to the same
+            // lifecycle.
             if (fragment == mQs) {
                 mQs = null;
             }
@@ -2725,11 +2712,11 @@ public class NotificationPanelView extends PanelView implements
     }
 
     public void setDozing(boolean dozing, boolean animate) {
-        if (dozing == mDozing) return;
+        if (dozing == mDozing)
+            return;
         mDozing = dozing;
 
-        if (mStatusBarState == StatusBarState.KEYGUARD
-                || mStatusBarState == StatusBarState.SHADE_LOCKED) {
+        if (mStatusBarState == StatusBarState.KEYGUARD || mStatusBarState == StatusBarState.SHADE_LOCKED) {
             updateDozingVisibilities(animate);
         }
 
@@ -2744,9 +2731,7 @@ public class NotificationPanelView extends PanelView implements
         mDarkAmountTarget = darkAmount;
         if (animate) {
             if (mInterpolatedDarkAmount == 0f || mInterpolatedDarkAmount == 1f) {
-                mDarkInterpolator = dozing
-                        ? Interpolators.FAST_OUT_SLOW_IN
-                        : Interpolators.TOUCH_RESPONSE_REVERSE;
+                mDarkInterpolator = dozing ? Interpolators.FAST_OUT_SLOW_IN : Interpolators.TOUCH_RESPONSE_REVERSE;
             }
             mNotificationStackScroller.notifyDarkAnimationStart(dozing);
             mDarkAnimator = ObjectAnimator.ofFloat(this, SET_DARK_AMOUNT_PROPERTY, darkAmount);
@@ -2770,8 +2755,7 @@ public class NotificationPanelView extends PanelView implements
     public void setPulsing(boolean pulsing) {
         mPulsing = pulsing;
         DozeParameters dozeParameters = DozeParameters.getInstance(mContext);
-        final boolean animatePulse = !dozeParameters.getDisplayNeedsBlanking()
-                && dozeParameters.getAlwaysOn();
+        final boolean animatePulse = !dozeParameters.getDisplayNeedsBlanking() && dozeParameters.getAlwaysOn();
         if (animatePulse) {
             mAnimateNextPositionUpdate = true;
         }
@@ -2795,13 +2779,14 @@ public class NotificationPanelView extends PanelView implements
     }
 
     public void setStatusAccessibilityImportance(int mode) {
-         mKeyguardStatusView.setImportantForAccessibility(mode);
+        mKeyguardStatusView.setImportantForAccessibility(mode);
     }
 
     /**
-     * TODO: this should be removed.
-     * It's not correct to pass this view forward because other classes will end up adding
-     * children to it. Theme will be out of sync.
+     * TODO: this should be removed. It's not correct to pass this view forward
+     * because other classes will end up adding children to it. Theme will be out of
+     * sync.
+     * 
      * @return bottom area view
      */
     public KeyguardBottomAreaView getKeyguardBottomAreaView() {
@@ -2821,8 +2806,7 @@ public class NotificationPanelView extends PanelView implements
         mExpandOffset = params != null ? params.getTopChange() : 0;
         updateQsExpansion();
         if (params != null) {
-            boolean hideIcons = params.getProgress(
-                    ActivityLaunchAnimator.ANIMATION_DELAY_ICON_FADE_IN, 100) == 0.0f;
+            boolean hideIcons = params.getProgress(ActivityLaunchAnimator.ANIMATION_DELAY_ICON_FADE_IN, 100) == 0.0f;
             if (hideIcons != mHideIconsDuringNotificationLaunch) {
                 mHideIconsDuringNotificationLaunch = hideIcons;
                 if (!hideIcons) {
@@ -2848,17 +2832,15 @@ public class NotificationPanelView extends PanelView implements
         mVerticalTranslationListener.remove(verticalTranslationListener);
     }
 
-    public void setHeadsUpAppearanceController(
-            HeadsUpAppearanceController headsUpAppearanceController) {
+    public void setHeadsUpAppearanceController(HeadsUpAppearanceController headsUpAppearanceController) {
         mHeadsUpAppearanceController = headsUpAppearanceController;
     }
 
     /**
-     * Starts the animation before we dismiss Keyguard, i.e. an disappearing animation on the
-     * security view of the bouncer.
+     * Starts the animation before we dismiss Keyguard, i.e. an disappearing
+     * animation on the security view of the bouncer.
      */
     public void onBouncerPreHideAnimation() {
-        setKeyguardStatusViewVisibility(mStatusBarState, true /* keyguardFadingAway */,
-                false /* goingToFullShade */);
+        setKeyguardStatusViewVisibility(mStatusBarState, true /* keyguardFadingAway */, false /* goingToFullShade */);
     }
 }
diff --git a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarWindowView.java b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarWindowView.java
index fa763c852cd..5372b8ebbbf 100644
--- a/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarWindowView.java
+++ b/packages/SystemUI/src/com/android/systemui/statusbar/phone/StatusBarWindowView.java
@@ -20,9 +20,11 @@ import android.annotation.ColorInt;
 import android.annotation.DrawableRes;
 import android.annotation.LayoutRes;
 import android.app.StatusBarManager;
+import android.content.ContentResolver;
 import android.content.Context;
 import android.content.res.Configuration;
 import android.content.res.TypedArray;
+import android.database.ContentObserver;
 import android.graphics.Canvas;
 import android.graphics.Paint;
 import android.graphics.PorterDuff;
@@ -33,11 +35,20 @@ import android.media.AudioManager;
 import android.media.session.MediaSessionLegacyHelper;
 import android.net.Uri;
 import android.os.Bundle;
+import android.os.Handler;
 import android.os.IBinder;
+import android.os.IPowerManager;
+import android.os.PowerManager;
+import android.os.RemoteException;
+import android.os.ServiceManager;
 import android.os.SystemClock;
+import android.os.UserHandle;
+import android.provider.Settings;
 import android.util.AttributeSet;
+import android.util.Log;
 import android.view.ActionMode;
 import android.view.DisplayCutout;
+import android.view.GestureDetector;
 import android.view.InputDevice;
 import android.view.InputQueue;
 import android.view.KeyEvent;
@@ -66,7 +77,6 @@ import com.android.systemui.statusbar.stack.NotificationStackScrollLayout;
 import java.io.FileDescriptor;
 import java.io.PrintWriter;
 
-
 public class StatusBarWindowView extends FrameLayout {
     public static final String TAG = "StatusBarWindowView";
     public static final boolean DEBUG = StatusBar.DEBUG;
@@ -85,7 +95,8 @@ public class StatusBarWindowView extends FrameLayout {
     private final Paint mTransparentSrcPaint = new Paint();
     private FalsingManager mFalsingManager;
 
-    // Implements the floating action mode for TextView's Cut/Copy/Past menu. Normally provided by
+    // Implements the floating action mode for TextView's Cut/Copy/Past menu.
+    // Normally provided by
     // DecorView, but since this is a special window we have to roll our own.
     private View mFloatingActionModeOriginatingView;
     private ActionMode mFloatingActionMode;
@@ -97,18 +108,26 @@ public class StatusBarWindowView extends FrameLayout {
     private boolean mExpandAnimationPending;
 
     /**
-     * If set to true, the current gesture started below the notch and we need to dispatch touch
-     * events manually as it's outside of the regular view bounds.
+     * If set to true, the current gesture started below the notch and we need to
+     * dispatch touch events manually as it's outside of the regular view bounds.
      */
     private boolean mExpandingBelowNotch;
 
+    private int mStatusBarHeaderHeight;
+    private boolean mDoubleTapToSleepEnabled;
+    private GestureDetector mDoubleTapGesture;
+    private Handler mHandler = new Handler();
+    private SettingsObserver mSettingsObserver;
+
     public StatusBarWindowView(Context context, AttributeSet attrs) {
         super(context, attrs);
         setMotionEventSplittingEnabled(false);
         mTransparentSrcPaint.setColor(0);
         mTransparentSrcPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC));
         mFalsingManager = FalsingManager.getInstance(context);
-        mDoubleTapHelper = new DoubleTapHelper(this, active -> {}, () -> {
+        mSettingsObserver = new SettingsObserver(mHandler);
+        mDoubleTapHelper = new DoubleTapHelper(this, active -> {
+        }, () -> {
             mService.wakeUpIfDozing(SystemClock.uptimeMillis(), this);
             return true;
         }, null, null);
@@ -117,8 +136,7 @@ public class StatusBarWindowView extends FrameLayout {
     @Override
     protected boolean fitSystemWindows(Rect insets) {
         if (getFitsSystemWindows()) {
-            boolean paddingChanged = insets.top != getPaddingTop()
-                    || insets.bottom != getPaddingBottom();
+            boolean paddingChanged = insets.top != getPaddingTop() || insets.bottom != getPaddingBottom();
 
             int rightCutout = 0;
             int leftCutout = 0;
@@ -131,7 +149,8 @@ public class StatusBarWindowView extends FrameLayout {
             int targetLeft = Math.max(insets.left, leftCutout);
             int targetRight = Math.max(insets.right, rightCutout);
 
-            // Super-special right inset handling, because scrims and backdrop need to ignore it.
+            // Super-special right inset handling, because scrims and backdrop need to
+            // ignore it.
             if (targetRight != mRightInset || targetLeft != mLeftInset) {
                 mRightInset = targetRight;
                 mLeftInset = targetLeft;
@@ -150,9 +169,7 @@ public class StatusBarWindowView extends FrameLayout {
                 mLeftInset = 0;
                 applyMargins();
             }
-            boolean changed = getPaddingLeft() != 0
-                    || getPaddingRight() != 0
-                    || getPaddingTop() != 0
+            boolean changed = getPaddingLeft() != 0 || getPaddingRight() != 0 || getPaddingTop() != 0
                     || getPaddingBottom() != 0;
             if (changed) {
                 setPadding(0, 0, 0, 0);
@@ -168,8 +185,7 @@ public class StatusBarWindowView extends FrameLayout {
             View child = getChildAt(i);
             if (child.getLayoutParams() instanceof LayoutParams) {
                 LayoutParams lp = (LayoutParams) child.getLayoutParams();
-                if (!lp.ignoreRightInset
-                        && (lp.rightMargin != mRightInset || lp.leftMargin != mLeftInset)) {
+                if (!lp.ignoreRightInset && (lp.rightMargin != mRightInset || lp.leftMargin != mLeftInset)) {
                     lp.rightMargin = mRightInset;
                     lp.leftMargin = mLeftInset;
                     child.requestLayout();
@@ -191,8 +207,7 @@ public class StatusBarWindowView extends FrameLayout {
     @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
-        mStackScrollLayout = (NotificationStackScrollLayout) findViewById(
-                R.id.notification_stack_scroller);
+        mStackScrollLayout = (NotificationStackScrollLayout) findViewById(R.id.notification_stack_scroller);
         mNotificationPanel = (NotificationPanelView) findViewById(R.id.notification_panel);
         mBrightnessMirror = findViewById(R.id.brightness_mirror);
     }
@@ -220,11 +235,25 @@ public class StatusBarWindowView extends FrameLayout {
     }
 
     @Override
-    protected void onAttachedToWindow () {
+    protected void onAttachedToWindow() {
         super.onAttachedToWindow();
+        mSettingsObserver.observe();
+        mDoubleTapGesture = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {
+            @Override
+            public boolean onDoubleTap(MotionEvent e) {
+                PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+                if (pm != null) {
+                    pm.goToSleep(e.getEventTime());
+                }
+
+                return true;
+            }
+        });
 
-        // We need to ensure that our window doesn't suffer from overdraw which would normally
-        // occur if our window is translucent. Since we are drawing the whole window anyway with
+        // We need to ensure that our window doesn't suffer from overdraw which would
+        // normally
+        // occur if our window is translucent. Since we are drawing the whole window
+        // anyway with
         // the scrim, we don't need the window to be cleared in the beginning.
         if (mService.isScrimSrcModeEnabled()) {
             IBinder windowToken = getWindowToken();
@@ -238,6 +267,12 @@ public class StatusBarWindowView extends FrameLayout {
         }
     }
 
+    @Override
+    protected void onDetachedFromWindow() {
+        super.onDetachedFromWindow();
+        mSettingsObserver.unobserve();
+    }
+
     @Override
     public boolean dispatchKeyEvent(KeyEvent event) {
         if (mService.interceptMediaKey(event)) {
@@ -248,28 +283,28 @@ public class StatusBarWindowView extends FrameLayout {
         }
         boolean down = event.getAction() == KeyEvent.ACTION_DOWN;
         switch (event.getKeyCode()) {
-            case KeyEvent.KEYCODE_BACK:
-                if (!down) {
-                    mService.onBackPressed();
-                }
+        case KeyEvent.KEYCODE_BACK:
+            if (!down) {
+                mService.onBackPressed();
+            }
+            return true;
+        case KeyEvent.KEYCODE_MENU:
+            if (!down) {
+                return mService.onMenuPressed();
+            }
+        case KeyEvent.KEYCODE_SPACE:
+            if (!down) {
+                return mService.onSpacePressed();
+            }
+            break;
+        case KeyEvent.KEYCODE_VOLUME_DOWN:
+        case KeyEvent.KEYCODE_VOLUME_UP:
+            if (mService.isDozing()) {
+                MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(event,
+                        AudioManager.USE_DEFAULT_STREAM_TYPE, true);
                 return true;
-            case KeyEvent.KEYCODE_MENU:
-                if (!down) {
-                    return mService.onMenuPressed();
-                }
-            case KeyEvent.KEYCODE_SPACE:
-                if (!down) {
-                    return mService.onSpacePressed();
-                }
-                break;
-            case KeyEvent.KEYCODE_VOLUME_DOWN:
-            case KeyEvent.KEYCODE_VOLUME_UP:
-                if (mService.isDozing()) {
-                    MediaSessionLegacyHelper.getHelper(mContext).sendVolumeKeyEvent(
-                            event, AudioManager.USE_DEFAULT_STREAM_TYPE, true);
-                    return true;
-                }
-                break;
+            }
+            break;
         }
         return false;
     }
@@ -284,7 +319,8 @@ public class StatusBarWindowView extends FrameLayout {
         boolean isUp = ev.getActionMasked() == MotionEvent.ACTION_UP;
         boolean isCancel = ev.getActionMasked() == MotionEvent.ACTION_CANCEL;
 
-        // Reset manual touch dispatch state here but make sure the UP/CANCEL event still gets
+        // Reset manual touch dispatch state here but make sure the UP/CANCEL event
+        // still gets
         // delivered.
         boolean expandingBelowNotch = mExpandingBelowNotch;
         if (isUp || isCancel) {
@@ -300,8 +336,7 @@ public class StatusBarWindowView extends FrameLayout {
         if (isDown) {
             setTouchActive(true);
             mTouchCancelled = false;
-        } else if (ev.getActionMasked() == MotionEvent.ACTION_UP
-                || ev.getActionMasked() == MotionEvent.ACTION_CANCEL) {
+        } else if (ev.getActionMasked() == MotionEvent.ACTION_UP || ev.getActionMasked() == MotionEvent.ACTION_CANCEL) {
             setTouchActive(false);
         }
         if (mTouchCancelled || mExpandAnimationRunning || mExpandAnimationPending) {
@@ -309,8 +344,10 @@ public class StatusBarWindowView extends FrameLayout {
         }
         mFalsingManager.onTouchEvent(ev, getWidth(), getHeight());
         if (mBrightnessMirror != null && mBrightnessMirror.getVisibility() == VISIBLE) {
-            // Disallow new pointers while the brightness mirror is visible. This is so that you
-            // can't touch anything other than the brightness slider while the mirror is showing
+            // Disallow new pointers while the brightness mirror is visible. This is so that
+            // you
+            // can't touch anything other than the brightness slider while the mirror is
+            // showing
             // and the rest of the panel is transparent.
             if (ev.getActionMasked() == MotionEvent.ACTION_POINTER_DOWN) {
                 return false;
@@ -323,8 +360,10 @@ public class StatusBarWindowView extends FrameLayout {
             mService.mDozeScrimController.extendPulse();
         }
 
-        // In case we start outside of the view bounds (below the status bar), we need to dispatch
-        // the touch manually as the view system can't accomodate for touches outside of the
+        // In case we start outside of the view bounds (below the status bar), we need
+        // to dispatch
+        // the touch manually as the view system can't accomodate for touches outside of
+        // the
         // regular view bounds.
         if (isDown && ev.getY() >= mBottom) {
             mExpandingBelowNotch = true;
@@ -344,10 +383,11 @@ public class StatusBarWindowView extends FrameLayout {
             return true;
         }
         boolean intercept = false;
-        if (mNotificationPanel.isFullyExpanded()
-                && mStackScrollLayout.getVisibility() == View.VISIBLE
-                && mService.getBarState() == StatusBarState.KEYGUARD
-                && !mService.isBouncerShowing()
+        if (mDoubleTapToSleepEnabled && ev.getY() < mStatusBarHeaderHeight) {
+            mDoubleTapGesture.onTouchEvent(ev);
+        }
+        if (mNotificationPanel.isFullyExpanded() && mStackScrollLayout.getVisibility() == View.VISIBLE
+                && mService.getBarState() == StatusBarState.KEYGUARD && !mService.isBouncerShowing()
                 && !mService.isDozing()) {
             intercept = mDragDownHelper.onInterceptTouchEvent(ev);
         }
@@ -371,8 +411,7 @@ public class StatusBarWindowView extends FrameLayout {
             mDoubleTapHelper.onTouchEvent(ev);
             handled = true;
         }
-        if ((mService.getBarState() == StatusBarState.KEYGUARD && !handled)
-                || mDragDownHelper.isDraggingDown()) {
+        if ((mService.getBarState() == StatusBarState.KEYGUARD && !handled) || mDragDownHelper.isDraggingDown()) {
             // we still want to finish our drag down gesture when locking the screen
             handled = mDragDownHelper.onTouchEvent(ev);
         }
@@ -390,7 +429,8 @@ public class StatusBarWindowView extends FrameLayout {
     public void onDraw(Canvas canvas) {
         super.onDraw(canvas);
         if (mService.isScrimSrcModeEnabled()) {
-            // We need to ensure that our window is always drawn fully even when we have paddings,
+            // We need to ensure that our window is always drawn fully even when we have
+            // paddings,
             // since we simulate it to be opaque.
             int paddedBottom = getHeight() - getPaddingBottom();
             int paddedRight = getWidth() - getPaddingRight();
@@ -401,12 +441,10 @@ public class StatusBarWindowView extends FrameLayout {
                 canvas.drawRect(0, paddedBottom, getWidth(), getHeight(), mTransparentSrcPaint);
             }
             if (getPaddingLeft() != 0) {
-                canvas.drawRect(0, getPaddingTop(), getPaddingLeft(), paddedBottom,
-                        mTransparentSrcPaint);
+                canvas.drawRect(0, getPaddingTop(), getPaddingLeft(), paddedBottom, mTransparentSrcPaint);
             }
             if (getPaddingRight() != 0) {
-                canvas.drawRect(paddedRight, getPaddingTop(), getWidth(), paddedBottom,
-                        mTransparentSrcPaint);
+                canvas.drawRect(paddedRight, getPaddingTop(), getWidth(), paddedBottom, mTransparentSrcPaint);
             }
         }
         if (DEBUG) {
@@ -427,8 +465,7 @@ public class StatusBarWindowView extends FrameLayout {
     public void cancelCurrentTouch() {
         if (mTouchActive) {
             final long now = SystemClock.uptimeMillis();
-            MotionEvent event = MotionEvent.obtain(now, now,
-                    MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);
+            MotionEvent event = MotionEvent.obtain(now, now, MotionEvent.ACTION_CANCEL, 0.0f, 0.0f, 0);
             event.setSource(InputDevice.SOURCE_TOUCHSCREEN);
             dispatchTouchEvent(event);
             event.recycle();
@@ -445,10 +482,14 @@ public class StatusBarWindowView extends FrameLayout {
     }
 
     public void dump(FileDescriptor fd, PrintWriter pw, String[] args) {
-        pw.print("  mExpandAnimationPending="); pw.println(mExpandAnimationPending);
-        pw.print("  mExpandAnimationRunning="); pw.println(mExpandAnimationRunning);
-        pw.print("  mTouchCancelled="); pw.println(mTouchCancelled);
-        pw.print("  mTouchActive="); pw.println(mTouchActive);
+        pw.print("  mExpandAnimationPending=");
+        pw.println(mExpandAnimationPending);
+        pw.print("  mExpandAnimationRunning=");
+        pw.println(mExpandAnimationRunning);
+        pw.print("  mTouchCancelled=");
+        pw.println(mTouchCancelled);
+        pw.print("  mTouchActive=");
+        pw.println(mTouchActive);
     }
 
     public class LayoutParams extends FrameLayout.LayoutParams {
@@ -463,47 +504,75 @@ public class StatusBarWindowView extends FrameLayout {
             super(c, attrs);
 
             TypedArray a = c.obtainStyledAttributes(attrs, R.styleable.StatusBarWindowView_Layout);
-            ignoreRightInset = a.getBoolean(
-                    R.styleable.StatusBarWindowView_Layout_ignoreRightInset, false);
+            ignoreRightInset = a.getBoolean(R.styleable.StatusBarWindowView_Layout_ignoreRightInset, false);
             a.recycle();
         }
     }
 
+    class SettingsObserver extends ContentObserver {
+        SettingsObserver(Handler handler) {
+            super(handler);
+        }
+
+        void observe() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.registerContentObserver(Settings.System.getUriFor(Settings.System.DOUBLE_TAP_SLEEP_GESTURE), false,
+                    this, UserHandle.USER_ALL);
+            update();
+        }
+
+        void unobserve() {
+            ContentResolver resolver = mContext.getContentResolver();
+            resolver.unregisterContentObserver(this);
+        }
+
+        @Override
+        public void onChange(boolean selfChange) {
+            update();
+        }
+
+        @Override
+        public void onChange(boolean selfChange, Uri uri) {
+            update();
+        }
+
+        public void update() {
+            ContentResolver resolver = mContext.getContentResolver();
+            mDoubleTapToSleepEnabled = Settings.System.getIntForUser(resolver, Settings.System.DOUBLE_TAP_SLEEP_GESTURE,
+                    1, UserHandle.USER_CURRENT) == 1;
+        }
+    }
+
     @Override
-    public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback,
-            int type) {
+    public ActionMode startActionModeForChild(View originalView, ActionMode.Callback callback, int type) {
         if (type == ActionMode.TYPE_FLOATING) {
             return startActionMode(originalView, callback, type);
         }
         return super.startActionModeForChild(originalView, callback, type);
     }
 
-    private ActionMode createFloatingActionMode(
-            View originatingView, ActionMode.Callback2 callback) {
+    private ActionMode createFloatingActionMode(View originatingView, ActionMode.Callback2 callback) {
         if (mFloatingActionMode != null) {
             mFloatingActionMode.finish();
         }
         cleanupFloatingActionModeViews();
         mFloatingToolbar = new FloatingToolbar(mFakeWindow);
-        final FloatingActionMode mode =
-                new FloatingActionMode(mContext, callback, originatingView, mFloatingToolbar);
+        final FloatingActionMode mode = new FloatingActionMode(mContext, callback, originatingView, mFloatingToolbar);
         mFloatingActionModeOriginatingView = originatingView;
-        mFloatingToolbarPreDrawListener =
-                new ViewTreeObserver.OnPreDrawListener() {
-                    @Override
-                    public boolean onPreDraw() {
-                        mode.updateViewLocationInWindow();
-                        return true;
-                    }
-                };
+        mFloatingToolbarPreDrawListener = new ViewTreeObserver.OnPreDrawListener() {
+            @Override
+            public boolean onPreDraw() {
+                mode.updateViewLocationInWindow();
+                return true;
+            }
+        };
         return mode;
     }
 
     private void setHandledFloatingActionMode(ActionMode mode) {
         mFloatingActionMode = mode;
-        mFloatingActionMode.invalidate();  // Will show the floating toolbar if necessary.
-        mFloatingActionModeOriginatingView.getViewTreeObserver()
-                .addOnPreDrawListener(mFloatingToolbarPreDrawListener);
+        mFloatingActionMode.invalidate(); // Will show the floating toolbar if necessary.
+        mFloatingActionModeOriginatingView.getViewTreeObserver().addOnPreDrawListener(mFloatingToolbarPreDrawListener);
     }
 
     private void cleanupFloatingActionModeViews() {
@@ -521,8 +590,7 @@ public class StatusBarWindowView extends FrameLayout {
         }
     }
 
-    private ActionMode startActionMode(
-            View originatingView, ActionMode.Callback callback, int type) {
+    private ActionMode startActionMode(View originatingView, ActionMode.Callback callback, int type) {
         ActionMode.Callback2 wrappedCallback = new ActionModeCallback2Wrapper(callback);
         ActionMode mode = createFloatingActionMode(originatingView, wrappedCallback);
         if (mode != null && wrappedCallback.onCreateActionMode(mode, mode.getMenu())) {
@@ -808,4 +876,3 @@ public class StatusBarWindowView extends FrameLayout {
     };
 
 }
-
-- 
2.17.1

